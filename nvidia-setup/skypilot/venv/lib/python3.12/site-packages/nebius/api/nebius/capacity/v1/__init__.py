# 
# Generated by the nebius.base.protos.compiler.  DO NOT EDIT!
# 

"""Auto-generated Nebius SDK package for ``nebius.capacity.v1``"""

import builtins as builtins
import collections.abc as abc
import datetime as datetime
import google.protobuf.descriptor as descriptor_1
import google.protobuf.message as message_1
import google.protobuf.timestamp_pb2 as timestamp_pb2
import nebius.aio.client as client
import nebius.aio.request as request
import nebius.aio.request_kwargs as request_kwargs
import nebius.api.nebius.capacity.v1.capacity_block_group_pb2 as capacity_block_group_pb2
import nebius.api.nebius.capacity.v1.capacity_block_group_service_pb2 as capacity_block_group_service_pb2
import nebius.api.nebius.capacity.v1.capacity_interval_pb2 as capacity_interval_pb2
import nebius.api.nebius.capacity.v1.capacity_interval_service_pb2 as capacity_interval_service_pb2
import nebius.api.nebius.capacity.v1.resource_affinity_pb2 as resource_affinity_pb2
import nebius.api.nebius.common.v1 as v1_1
import nebius.api.nebius.common.v1.metadata_pb2 as metadata_pb2
import nebius.base.protos.descriptor as descriptor
import nebius.base.protos.pb_classes as pb_classes
import nebius.base.protos.pb_enum as pb_enum
import nebius.base.protos.unset as unset
import nebius.base.protos.well_known as well_known_1
import typing as typing
import typing_extensions as typing_extensions
#@ local imports here @#

# file: nebius/capacity/v1/resource_affinity.proto
class ResourceAffinityComputeV1(pb_classes.Message):
    """
    First version of Compute service resource affinity
    """
    
    __PB2_CLASS__ = resource_affinity_pb2.ResourceAffinityComputeV1
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.capacity.v1.ResourceAffinityComputeV1",resource_affinity_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        fabric: "builtins.str|None|unset.UnsetType" = unset.Unset,
        platform: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(fabric, unset.UnsetType):
            self.fabric = fabric
        if not isinstance(platform, unset.UnsetType):
            self.platform = platform
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "fabric",
            "platform",
        ]
    
    @builtins.property
    def fabric(self) -> "builtins.str":
        """
        The fabric where the Capacity Block Group is allocated.
        """
        
        return super()._get_field("fabric", explicit_presence=False,
        )
    @fabric.setter
    def fabric(self, value: "builtins.str|None") -> None:
        return super()._set_field("fabric",value,explicit_presence=False,
        )
    
    @builtins.property
    def platform(self) -> "builtins.str":
        """
        The platform for which the Capacity Block Group is allocated.
        """
        
        return super()._get_field("platform", explicit_presence=False,
        )
    @platform.setter
    def platform(self, value: "builtins.str|None") -> None:
        return super()._set_field("platform",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "fabric":"fabric",
        "platform":"platform",
    }
    
class ResourceAffinity(pb_classes.Message):
    """
    Specification of the Capacity Block Group.
    """
    
    __PB2_CLASS__ = resource_affinity_pb2.ResourceAffinity
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.capacity.v1.ResourceAffinity",resource_affinity_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_versions__(pb_classes.OneOf):
        name: builtins.str= "versions"
        
        def __init__(self, msg: "ResourceAffinity") -> None:
            super().__init__()
            self._message: "ResourceAffinity" = msg
    
    class __OneOfClass_versions_compute_v1__(__OneOfClass_versions__):
        field: typing.Literal["compute_v1"] = "compute_v1"
        
        def __init__(self, msg: "ResourceAffinity") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "ResourceAffinityComputeV1":
            return self._message.compute_v1
    
    @builtins.property
    def versions(self) -> __OneOfClass_versions_compute_v1__|None:
        field_name_1: str|None = super().which_field_in_oneof("versions")
        match field_name_1:
            case "compute_v1":
                return self.__OneOfClass_versions_compute_v1__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        compute_v1: "ResourceAffinityComputeV1|resource_affinity_pb2.ResourceAffinityComputeV1|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(compute_v1, unset.UnsetType):
            self.compute_v1 = compute_v1
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "compute_v1",
            "versions",
        ]
    
    @builtins.property
    def compute_v1(self) -> "ResourceAffinityComputeV1|None":
        """
        First version of the compute Resource Affinity.
        """
        
        return super()._get_field("compute_v1", explicit_presence=True,
        wrap=ResourceAffinityComputeV1,
        )
    @compute_v1.setter
    def compute_v1(self, value: "ResourceAffinityComputeV1|resource_affinity_pb2.ResourceAffinityComputeV1|None") -> None:
        return super()._set_field("compute_v1",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "compute_v1":"compute_v1",
        "versions":"versions",
    }
    
# file: nebius/capacity/v1/capacity_block_group.proto
class CapacityBlockGroupSpec(pb_classes.Message):
    """
    Capacity Block Group specification.
    """
    
    __PB2_CLASS__ = capacity_block_group_pb2.CapacityBlockGroupSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.capacity.v1.CapacityBlockGroupSpec",capacity_block_group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
    ) -> None:
        super().__init__(initial_message)
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
        ]
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
    }
    
class CurrentContinuousInterval(pb_classes.Message):
    """
    Current, last or future concatenation of Capacity Intervals in a Capacity Block Group.
    """
    
    __PB2_CLASS__ = capacity_block_group_pb2.CurrentContinuousInterval
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.capacity.v1.CurrentContinuousInterval",capacity_block_group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
        "start_time": well_known_1.ts_mask,
        "end_time": well_known_1.ts_mask,
    }
    
    class State(pb_enum.Enum):
        """
        Shows a state of a Continuous Interval.
        """
        
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.capacity.v1.CurrentContinuousInterval.State",capacity_block_group_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        STATE_UNSPECIFIED = 0
        """
        Shouldn't happen.
        """
        
        STATE_SCHEDULED = 1
        """
        Continuous Interval is in the future.
        """
        
        STATE_ACTIVE = 2
        """
        Continuous Interval is active.
        """
        
        STATE_EXPIRED = 3
        """
        Continuous Interval is in the past.
        """
        
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        start_time: "timestamp_pb2.Timestamp|datetime.datetime|None|unset.UnsetType" = unset.Unset,
        end_time: "timestamp_pb2.Timestamp|datetime.datetime|None|unset.UnsetType" = unset.Unset,
        quantity: "builtins.int|None|unset.UnsetType" = unset.Unset,
        state: "CurrentContinuousInterval.State|capacity_block_group_pb2.CurrentContinuousInterval.State|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(start_time, unset.UnsetType):
            self.start_time = start_time
        if not isinstance(end_time, unset.UnsetType):
            self.end_time = end_time
        if not isinstance(quantity, unset.UnsetType):
            self.quantity = quantity
        if not isinstance(state, unset.UnsetType):
            self.state = state
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "start_time",
            "end_time",
            "quantity",
            "state",
            "State",
        ]
    
    @builtins.property
    def start_time(self) -> "datetime.datetime":
        """
        Start time of the first interval(s) in Continuous Interval.
        """
        
        return super()._get_field("start_time", explicit_presence=False,
        wrap=well_known_1.from_timestamp
        )
    @start_time.setter
    def start_time(self, value: "timestamp_pb2.Timestamp|datetime.datetime|None") -> None:
        return super()._set_field("start_time",value,explicit_presence=False,
        unwrap=well_known_1.to_timestamp
        )
    
    @builtins.property
    def end_time(self) -> "datetime.datetime":
        """
        End time of the last interval(s) in Continuous Interval.
        """
        
        return super()._get_field("end_time", explicit_presence=False,
        wrap=well_known_1.from_timestamp
        )
    @end_time.setter
    def end_time(self, value: "timestamp_pb2.Timestamp|datetime.datetime|None") -> None:
        return super()._set_field("end_time",value,explicit_presence=False,
        unwrap=well_known_1.to_timestamp
        )
    
    @builtins.property
    def quantity(self) -> "builtins.int":
        """
        Quota quantity that is currently set, was set or will be set in the Continuous Interval depending on it's
        start_time and end_time.
        If the Continuous Interval is currently active, quantity is the sum of quantities of the currently active
        non-zero intervals.
        If the Continuous Interval is in the past, quantity is the sum of quantities of the last non-zero active
        intervals.
        If the Continuous Interval is in the future, quantity is the sum of the quantities of the first scheduled
        non-zero active intervals.
        """
        
        return super()._get_field("quantity", explicit_presence=False,
        )
    @quantity.setter
    def quantity(self, value: "builtins.int|None") -> None:
        return super()._set_field("quantity",value,explicit_presence=False,
        )
    
    @builtins.property
    def state(self) -> "CurrentContinuousInterval.State":
        """
        Continuous Interval state.
        """
        
        return super()._get_field("state", explicit_presence=False,
        wrap=CurrentContinuousInterval.State,
        )
    @state.setter
    def state(self, value: "CurrentContinuousInterval.State|capacity_block_group_pb2.CurrentContinuousInterval.State|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "start_time":"start_time",
        "end_time":"end_time",
        "quantity":"quantity",
        "state":"state",
        "State":"State",
    }
    
class CapacityBlockGroupStatus(pb_classes.Message):
    """
    Capacity Block Group status.
    """
    
    __PB2_CLASS__ = capacity_block_group_pb2.CapacityBlockGroupStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.capacity.v1.CapacityBlockGroupStatus",capacity_block_group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
        "next_change_at": well_known_1.ts_mask,
    }
    
    class State(pb_enum.Enum):
        """
        Shows the state of a Capacity Block Group with respect to its quota.
        """
        
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.capacity.v1.CapacityBlockGroupStatus.State",capacity_block_group_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        STATE_UNSPECIFIED = 0
        """
        Shouldn't happen.
        """
        
        STATE_ALLOCATING = 1
        """
        Capacity Block Group quota is being allocated as one or more capacity intervals have started.
        """
        
        STATE_ACTIVE = 2
        """
        Capacity Block Group quota is already allocated and active as one or more capacity intervals are active.
        """
        
        STATE_SHUTTING = 3
        """
        Capacity Block Group is being shut down due to absence of active intervals at the time.
        """
        
        STATE_INACTIVE = 4
        """
        Capacity Block Group is inactive due to absence of active intervals at the time.
        """
        
    
    class UsageState(pb_enum.Enum):
        """
        Shows the usage state if a Capacity Block Group quota.
        """
        
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.capacity.v1.CapacityBlockGroupStatus.UsageState",capacity_block_group_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        USAGE_STATE_UNSPECIFIED = 0
        """
        Shouldn't happen.
        """
        
        USAGE_STATE_USED = 1
        """
        Capacity Block Group quota is actively in use.
        """
        
        USAGE_STATE_NOT_USED = 2
        """
        Capacity Block Group quota is not currently in use.
        """
        
        USAGE_STATE_UNKNOWN = 3
        """
        Capacity Block Group region is unreachable, the current usage is therefore unknown.
        Please, retry the request later.
        """
        
    
    class __OneOfClass__next_change_to__(pb_classes.OneOf):
        name: builtins.str= "_next_change_to"
        
        def __init__(self, msg: "CapacityBlockGroupStatus") -> None:
            super().__init__()
            self._message: "CapacityBlockGroupStatus" = msg
    
    class __OneOfClass__next_change_to_next_change_to__(__OneOfClass__next_change_to__):
        field: typing.Literal["next_change_to"] = "next_change_to"
        
        def __init__(self, msg: "CapacityBlockGroupStatus") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.next_change_to
    
    @builtins.property
    def _next_change_to(self) -> __OneOfClass__next_change_to_next_change_to__|None:
        field_name_1: str|None = super().which_field_in_oneof("_next_change_to")
        match field_name_1:
            case "next_change_to":
                return self.__OneOfClass__next_change_to_next_change_to__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        region: "builtins.str|None|unset.UnsetType" = unset.Unset,
        resource_affinity: "ResourceAffinity|resource_affinity_pb2.ResourceAffinity|None|unset.UnsetType" = unset.Unset,
        service: "builtins.str|None|unset.UnsetType" = unset.Unset,
        state: "CapacityBlockGroupStatus.State|capacity_block_group_pb2.CapacityBlockGroupStatus.State|None|unset.UnsetType" = unset.Unset,
        current_limit: "builtins.int|None|unset.UnsetType" = unset.Unset,
        usage: "builtins.int|None|unset.UnsetType" = unset.Unset,
        usage_percentage: "builtins.str|None|unset.UnsetType" = unset.Unset,
        next_change_at: "timestamp_pb2.Timestamp|datetime.datetime|None|unset.UnsetType" = unset.Unset,
        next_change_to: "builtins.int|None|unset.UnsetType" = unset.Unset,
        current_continuous_interval: "CurrentContinuousInterval|capacity_block_group_pb2.CurrentContinuousInterval|None|unset.UnsetType" = unset.Unset,
        usage_state: "CapacityBlockGroupStatus.UsageState|capacity_block_group_pb2.CapacityBlockGroupStatus.UsageState|None|unset.UnsetType" = unset.Unset,
        reconciling: "builtins.bool|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(region, unset.UnsetType):
            self.region = region
        if not isinstance(resource_affinity, unset.UnsetType):
            self.resource_affinity = resource_affinity
        if not isinstance(service, unset.UnsetType):
            self.service = service
        if not isinstance(state, unset.UnsetType):
            self.state = state
        if not isinstance(current_limit, unset.UnsetType):
            self.current_limit = current_limit
        if not isinstance(usage, unset.UnsetType):
            self.usage = usage
        if not isinstance(usage_percentage, unset.UnsetType):
            self.usage_percentage = usage_percentage
        if not isinstance(next_change_at, unset.UnsetType):
            self.next_change_at = next_change_at
        if not isinstance(next_change_to, unset.UnsetType):
            self.next_change_to = next_change_to
        if not isinstance(current_continuous_interval, unset.UnsetType):
            self.current_continuous_interval = current_continuous_interval
        if not isinstance(usage_state, unset.UnsetType):
            self.usage_state = usage_state
        if not isinstance(reconciling, unset.UnsetType):
            self.reconciling = reconciling
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "region",
            "resource_affinity",
            "service",
            "state",
            "current_limit",
            "usage",
            "usage_percentage",
            "next_change_at",
            "next_change_to",
            "current_continuous_interval",
            "usage_state",
            "reconciling",
            "_next_change_to",
            "State",
            "UsageState",
        ]
    
    @builtins.property
    def region(self) -> "builtins.str":
        """
        Name of the region where the Capacity Block Group is allocated.
        Example: "eu-north1".
        """
        
        return super()._get_field("region", explicit_presence=False,
        )
    @region.setter
    def region(self, value: "builtins.str|None") -> None:
        return super()._set_field("region",value,explicit_presence=False,
        )
    
    @builtins.property
    def resource_affinity(self) -> "ResourceAffinity":
        """
        Specification of the Capacity Block Group.
        """
        
        return super()._get_field("resource_affinity", explicit_presence=False,
        wrap=ResourceAffinity,
        )
    @resource_affinity.setter
    def resource_affinity(self, value: "ResourceAffinity|resource_affinity_pb2.ResourceAffinity|None") -> None:
        return super()._set_field("resource_affinity",value,explicit_presence=False,
        )
    
    @builtins.property
    def service(self) -> "builtins.str":
        """
        Service for which the Capacity Block Group is allocated.
        """
        
        return super()._get_field("service", explicit_presence=False,
        )
    @service.setter
    def service(self, value: "builtins.str|None") -> None:
        return super()._set_field("service",value,explicit_presence=False,
        )
    
    @builtins.property
    def state(self) -> "CapacityBlockGroupStatus.State":
        """
        Capacity Block Group state with respect to quota allocation.
        """
        
        return super()._get_field("state", explicit_presence=False,
        wrap=CapacityBlockGroupStatus.State,
        )
    @state.setter
    def state(self, value: "CapacityBlockGroupStatus.State|capacity_block_group_pb2.CapacityBlockGroupStatus.State|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    @builtins.property
    def current_limit(self) -> "builtins.int":
        """
        Capacity Block Group current quota limit.
        """
        
        return super()._get_field("current_limit", explicit_presence=False,
        )
    @current_limit.setter
    def current_limit(self, value: "builtins.int|None") -> None:
        return super()._set_field("current_limit",value,explicit_presence=False,
        )
    
    @builtins.property
    def usage(self) -> "builtins.int":
        """
        Capacity Block Group quota usage.
        """
        
        return super()._get_field("usage", explicit_presence=False,
        )
    @usage.setter
    def usage(self, value: "builtins.int|None") -> None:
        return super()._set_field("usage",value,explicit_presence=False,
        )
    
    @builtins.property
    def usage_percentage(self) -> "builtins.str":
        """
        Capacity Block Group quota usage percentage.
        """
        
        return super()._get_field("usage_percentage", explicit_presence=False,
        )
    @usage_percentage.setter
    def usage_percentage(self, value: "builtins.str|None") -> None:
        return super()._set_field("usage_percentage",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_change_at(self) -> "datetime.datetime":
        """
        Time of the next Capacity Block Group quota change.
        """
        
        return super()._get_field("next_change_at", explicit_presence=False,
        wrap=well_known_1.from_timestamp
        )
    @next_change_at.setter
    def next_change_at(self, value: "timestamp_pb2.Timestamp|datetime.datetime|None") -> None:
        return super()._set_field("next_change_at",value,explicit_presence=False,
        unwrap=well_known_1.to_timestamp
        )
    
    @builtins.property
    def next_change_to(self) -> "builtins.int|None":
        """
        The next expected change of the Capacity Block Group quota limit.
        the quota limit change that is currently performed.
        """
        
        return super()._get_field("next_change_to", explicit_presence=True,
        )
    @next_change_to.setter
    def next_change_to(self, value: "builtins.int|None") -> None:
        return super()._set_field("next_change_to",value,explicit_presence=True,
        )
    
    @builtins.property
    def current_continuous_interval(self) -> "CurrentContinuousInterval":
        """
        Current concatenation of non-zero Capacity Intervals that overlap or follow each other without a break.
        If all Capacity Intervals are in the past, returns the last Continuous Interval.
        If all Capacity Intervals are in the future, returns the first Continuous Interval scheduled.
        """
        
        return super()._get_field("current_continuous_interval", explicit_presence=False,
        wrap=CurrentContinuousInterval,
        )
    @current_continuous_interval.setter
    def current_continuous_interval(self, value: "CurrentContinuousInterval|capacity_block_group_pb2.CurrentContinuousInterval|None") -> None:
        return super()._set_field("current_continuous_interval",value,explicit_presence=False,
        )
    
    @builtins.property
    def usage_state(self) -> "CapacityBlockGroupStatus.UsageState":
        """
        Capacity Block Group quota usage state.
        """
        
        return super()._get_field("usage_state", explicit_presence=False,
        wrap=CapacityBlockGroupStatus.UsageState,
        )
    @usage_state.setter
    def usage_state(self, value: "CapacityBlockGroupStatus.UsageState|capacity_block_group_pb2.CapacityBlockGroupStatus.UsageState|None") -> None:
        return super()._set_field("usage_state",value,explicit_presence=False,
        )
    
    @builtins.property
    def reconciling(self) -> "builtins.bool":
        """
        Shows that changes are in flight.
        """
        
        return super()._get_field("reconciling", explicit_presence=False,
        )
    @reconciling.setter
    def reconciling(self, value: "builtins.bool|None") -> None:
        return super()._set_field("reconciling",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "region":"region",
        "resource_affinity":"resource_affinity",
        "service":"service",
        "state":"state",
        "current_limit":"current_limit",
        "usage":"usage",
        "usage_percentage":"usage_percentage",
        "next_change_at":"next_change_at",
        "next_change_to":"next_change_to",
        "current_continuous_interval":"current_continuous_interval",
        "usage_state":"usage_state",
        "reconciling":"reconciling",
        "_next_change_to":"_next_change_to",
        "State":"State",
        "UsageState":"UsageState",
    }
    
class CapacityBlockGroup(pb_classes.Message):
    """
    Capacity Block Group is a parent resource for Capacity Intervals.
    """
    
    __PB2_CLASS__ = capacity_block_group_pb2.CapacityBlockGroup
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.capacity.v1.CapacityBlockGroup",capacity_block_group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "CapacityBlockGroupSpec|capacity_block_group_pb2.CapacityBlockGroupSpec|None|unset.UnsetType" = unset.Unset,
        status: "CapacityBlockGroupStatus|capacity_block_group_pb2.CapacityBlockGroupStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "CapacityBlockGroupSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=CapacityBlockGroupSpec,
        )
    @spec.setter
    def spec(self, value: "CapacityBlockGroupSpec|capacity_block_group_pb2.CapacityBlockGroupSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "CapacityBlockGroupStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=CapacityBlockGroupStatus,
        )
    @status.setter
    def status(self, value: "CapacityBlockGroupStatus|capacity_block_group_pb2.CapacityBlockGroupStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
# file: nebius/capacity/v1/capacity_block_group_service.proto
class GetCapacityBlockGroupRequest(pb_classes.Message):
    """
    Get a Capacity Block Group by its ID.
    """
    
    __PB2_CLASS__ = capacity_block_group_service_pb2.GetCapacityBlockGroupRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.capacity.v1.GetCapacityBlockGroupRequest",capacity_block_group_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        """
        ID of the Capacity Block Group.
        """
        
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class GetCapacityBlockGroupByResourceAffinityRequest(pb_classes.Message):
    """
    Get a Capacity Block Group in a Tenant by its Resource Affinity.
    """
    
    __PB2_CLASS__ = capacity_block_group_service_pb2.GetCapacityBlockGroupByResourceAffinityRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.capacity.v1.GetCapacityBlockGroupByResourceAffinityRequest",capacity_block_group_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        region: "builtins.str|None|unset.UnsetType" = unset.Unset,
        resource_affinity: "ResourceAffinity|resource_affinity_pb2.ResourceAffinity|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(region, unset.UnsetType):
            self.region = region
        if not isinstance(resource_affinity, unset.UnsetType):
            self.resource_affinity = resource_affinity
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "region",
            "resource_affinity",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        Tenant ID of the Capacity Block Group.
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def region(self) -> "builtins.str":
        """
        Name of the region where the Capacity Block Group is allocated.
        Example: "eu-north1".
        """
        
        return super()._get_field("region", explicit_presence=False,
        )
    @region.setter
    def region(self, value: "builtins.str|None") -> None:
        return super()._set_field("region",value,explicit_presence=False,
        )
    
    @builtins.property
    def resource_affinity(self) -> "ResourceAffinity":
        """
        Specifications of the Capacity Block Group.
        """
        
        return super()._get_field("resource_affinity", explicit_presence=False,
        wrap=ResourceAffinity,
        )
    @resource_affinity.setter
    def resource_affinity(self, value: "ResourceAffinity|resource_affinity_pb2.ResourceAffinity|None") -> None:
        return super()._set_field("resource_affinity",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "region":"region",
        "resource_affinity":"resource_affinity",
    }
    
class ListCapacityBlockGroupsRequest(pb_classes.Message):
    """
    List Capacity Block Groups by a Tenant ID.
    """
    
    __PB2_CLASS__ = capacity_block_group_service_pb2.ListCapacityBlockGroupsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.capacity.v1.ListCapacityBlockGroupsRequest",capacity_block_group_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        Tenant ID of the Capacity Block Group.
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Page size. Must be between [1...200].
        Optional; if not specified, a reasonable default will be chosen by the service.
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Listing continuation token. Pass an empty string to start listing from the first page.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
    }
    
class ListCapacityBlockGroupsResponse(pb_classes.Message):
    """
    All existing Capacity Block Groups in a Tenant.
    """
    
    __PB2_CLASS__ = capacity_block_group_service_pb2.ListCapacityBlockGroupsResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.capacity.v1.ListCapacityBlockGroupsResponse",capacity_block_group_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[CapacityBlockGroup]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[CapacityBlockGroup]":
        """
        List of Capacity Block Groups on this result page.
        """
        
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(CapacityBlockGroup,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[CapacityBlockGroup]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        """
        Listing continuation token for the next page of results.
        """
        
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    
class ListCapacityBlockGroupResourcesRequest(pb_classes.Message):
    """
    List reservations instances in a Capacity Block Group by its ID.
    """
    
    __PB2_CLASS__ = capacity_block_group_service_pb2.ListCapacityBlockGroupResourcesRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.capacity.v1.ListCapacityBlockGroupResourcesRequest",capacity_block_group_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        """
        ID of a Capacity Block Group.
        """
        
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListCapacityBlockGroupResourcesResponse(pb_classes.Message):
    """
    All VM instances' IDs that occupy the Capacity Block Group.
    """
    
    __PB2_CLASS__ = capacity_block_group_service_pb2.ListCapacityBlockGroupResourcesResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.capacity.v1.ListCapacityBlockGroupResourcesResponse",capacity_block_group_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        resource_ids: "abc.Iterable[builtins.str]|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(resource_ids, unset.UnsetType):
            self.resource_ids = resource_ids
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "resource_ids",
        ]
    
    @builtins.property
    def resource_ids(self) -> "abc.MutableSequence[builtins.str]":
        """
        List of instances' IDs.
        """
        
        return super()._get_field("resource_ids", explicit_presence=False,
        wrap=pb_classes.Repeated,
        )
    @resource_ids.setter
    def resource_ids(self, value: "abc.Iterable[builtins.str]|None") -> None:
        return super()._set_field("resource_ids",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "resource_ids":"resource_ids",
    }
    

class CapacityBlockGroupServiceClient(client.Client):
    """
    Capacity Block Group service provides read access to Capacity Block Groups resources.
    
    This class provides the client methods for the ``.nebius.capacity.v1.CapacityBlockGroupService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.capacity.v1.CapacityBlockGroupService",capacity_block_group_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.capacity.v1.CapacityBlockGroupService"
    
    def get(self,
        request: "GetCapacityBlockGroupRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request.Request["GetCapacityBlockGroupRequest","CapacityBlockGroup"]:
        """
        Get Capacity Block Group by its ID.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.capacity.v1.GetCapacityBlockGroupRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.capacity.v1.CapacityBlockGroup`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=capacity_block_group_pb2.CapacityBlockGroup,
            result_wrapper=pb_classes.simple_wrapper(CapacityBlockGroup),
            **kwargs,
        )
    
    def get_by_resource_affinity(self,
        request: "GetCapacityBlockGroupByResourceAffinityRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request.Request["GetCapacityBlockGroupByResourceAffinityRequest","CapacityBlockGroup"]:
        """
        Get Capacity Block Group by its specification.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.capacity.v1.GetCapacityBlockGroupByResourceAffinityRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.capacity.v1.CapacityBlockGroup`.
        """
        
        return super().request(
            method="GetByResourceAffinity",
            request=request,
            result_pb2_class=capacity_block_group_pb2.CapacityBlockGroup,
            result_wrapper=pb_classes.simple_wrapper(CapacityBlockGroup),
            **kwargs,
        )
    
    def list(self,
        request: "ListCapacityBlockGroupsRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request.Request["ListCapacityBlockGroupsRequest","ListCapacityBlockGroupsResponse"]:
        """
        List all Capacity Block Groups for the specified Tenant.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.capacity.v1.ListCapacityBlockGroupsRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.capacity.v1.ListCapacityBlockGroupsResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=capacity_block_group_service_pb2.ListCapacityBlockGroupsResponse,
            result_wrapper=pb_classes.simple_wrapper(ListCapacityBlockGroupsResponse),
            **kwargs,
        )
    
    def list_resources(self,
        request: "ListCapacityBlockGroupResourcesRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request.Request["ListCapacityBlockGroupResourcesRequest","ListCapacityBlockGroupResourcesResponse"]:
        """
        List virtual machines instances' IDs that occupy a Capacity Block Group by its ID.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.capacity.v1.ListCapacityBlockGroupResourcesRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.capacity.v1.ListCapacityBlockGroupResourcesResponse`.
        """
        
        return super().request(
            method="ListResources",
            request=request,
            result_pb2_class=capacity_block_group_service_pb2.ListCapacityBlockGroupResourcesResponse,
            result_wrapper=pb_classes.simple_wrapper(ListCapacityBlockGroupResourcesResponse),
            **kwargs,
        )
    

# file: nebius/capacity/v1/capacity_interval.proto
class CapacityIntervalSpec(pb_classes.Message):
    """
    Capacity Interval specification.
    """
    
    __PB2_CLASS__ = capacity_interval_pb2.CapacityIntervalSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.capacity.v1.CapacityIntervalSpec",capacity_interval_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
    ) -> None:
        super().__init__(initial_message)
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
        ]
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
    }
    
class CapacityIntervalStatus(pb_classes.Message):
    """
    Capacity Interval status data.
    """
    
    __PB2_CLASS__ = capacity_interval_pb2.CapacityIntervalStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.capacity.v1.CapacityIntervalStatus",capacity_interval_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
        "start_time": well_known_1.ts_mask,
        "end_time": well_known_1.ts_mask,
    }
    
    class State(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.capacity.v1.CapacityIntervalStatus.State",capacity_interval_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        STATE_UNSPECIFIED = 0
        """
        Shouldn't happen.
        """
        
        STATE_SCHEDULED = 1
        """
        Capacity Interval is fully in the future (now < start_time).
        """
        
        STATE_ACTIVE = 2
        """
        Capacity Interval is currently active (start_time <= now < end_time).
        """
        
        STATE_EXPIRED = 3
        """
        Capacity Interval is fully in the past (end_time <= now).
        """
        
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        container_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        region: "builtins.str|None|unset.UnsetType" = unset.Unset,
        resource_affinity: "ResourceAffinity|resource_affinity_pb2.ResourceAffinity|None|unset.UnsetType" = unset.Unset,
        service: "builtins.str|None|unset.UnsetType" = unset.Unset,
        quantity: "builtins.int|None|unset.UnsetType" = unset.Unset,
        start_time: "timestamp_pb2.Timestamp|datetime.datetime|None|unset.UnsetType" = unset.Unset,
        end_time: "timestamp_pb2.Timestamp|datetime.datetime|None|unset.UnsetType" = unset.Unset,
        state: "CapacityIntervalStatus.State|capacity_interval_pb2.CapacityIntervalStatus.State|None|unset.UnsetType" = unset.Unset,
        reconciling: "builtins.bool|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(container_id, unset.UnsetType):
            self.container_id = container_id
        if not isinstance(region, unset.UnsetType):
            self.region = region
        if not isinstance(resource_affinity, unset.UnsetType):
            self.resource_affinity = resource_affinity
        if not isinstance(service, unset.UnsetType):
            self.service = service
        if not isinstance(quantity, unset.UnsetType):
            self.quantity = quantity
        if not isinstance(start_time, unset.UnsetType):
            self.start_time = start_time
        if not isinstance(end_time, unset.UnsetType):
            self.end_time = end_time
        if not isinstance(state, unset.UnsetType):
            self.state = state
        if not isinstance(reconciling, unset.UnsetType):
            self.reconciling = reconciling
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "container_id",
            "region",
            "resource_affinity",
            "service",
            "quantity",
            "start_time",
            "end_time",
            "state",
            "reconciling",
            "State",
        ]
    
    @builtins.property
    def container_id(self) -> "builtins.str":
        """
        Tenant ID for which the Capacity Interval is created.
        """
        
        return super()._get_field("container_id", explicit_presence=False,
        )
    @container_id.setter
    def container_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("container_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def region(self) -> "builtins.str":
        """
        Name of the region where the Capacity Interval is created.
        Example: "eu-north1".
        """
        
        return super()._get_field("region", explicit_presence=False,
        )
    @region.setter
    def region(self, value: "builtins.str|None") -> None:
        return super()._set_field("region",value,explicit_presence=False,
        )
    
    @builtins.property
    def resource_affinity(self) -> "ResourceAffinity":
        """
        Specification of the Capacity Interval.
        """
        
        return super()._get_field("resource_affinity", explicit_presence=False,
        wrap=ResourceAffinity,
        )
    @resource_affinity.setter
    def resource_affinity(self, value: "ResourceAffinity|resource_affinity_pb2.ResourceAffinity|None") -> None:
        return super()._set_field("resource_affinity",value,explicit_presence=False,
        )
    
    @builtins.property
    def service(self) -> "builtins.str":
        """
        Service for which the Capacity Interval is created.
        """
        
        return super()._get_field("service", explicit_presence=False,
        )
    @service.setter
    def service(self, value: "builtins.str|None") -> None:
        return super()._set_field("service",value,explicit_presence=False,
        )
    
    @builtins.property
    def quantity(self) -> "builtins.int":
        """
        Resource quantity of the Capacity Interval.
        """
        
        return super()._get_field("quantity", explicit_presence=False,
        )
    @quantity.setter
    def quantity(self, value: "builtins.int|None") -> None:
        return super()._set_field("quantity",value,explicit_presence=False,
        )
    
    @builtins.property
    def start_time(self) -> "datetime.datetime":
        """
        Start time of the Capacity Interval.
        """
        
        return super()._get_field("start_time", explicit_presence=False,
        wrap=well_known_1.from_timestamp
        )
    @start_time.setter
    def start_time(self, value: "timestamp_pb2.Timestamp|datetime.datetime|None") -> None:
        return super()._set_field("start_time",value,explicit_presence=False,
        unwrap=well_known_1.to_timestamp
        )
    
    @builtins.property
    def end_time(self) -> "datetime.datetime":
        """
        End time of the Capacity Interval.
        """
        
        return super()._get_field("end_time", explicit_presence=False,
        wrap=well_known_1.from_timestamp
        )
    @end_time.setter
    def end_time(self, value: "timestamp_pb2.Timestamp|datetime.datetime|None") -> None:
        return super()._set_field("end_time",value,explicit_presence=False,
        unwrap=well_known_1.to_timestamp
        )
    
    @builtins.property
    def state(self) -> "CapacityIntervalStatus.State":
        """
        State of the Capacity Interval.
        """
        
        return super()._get_field("state", explicit_presence=False,
        wrap=CapacityIntervalStatus.State,
        )
    @state.setter
    def state(self, value: "CapacityIntervalStatus.State|capacity_interval_pb2.CapacityIntervalStatus.State|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    @builtins.property
    def reconciling(self) -> "builtins.bool":
        """
        Shows that changes are in flight.
        """
        
        return super()._get_field("reconciling", explicit_presence=False,
        )
    @reconciling.setter
    def reconciling(self, value: "builtins.bool|None") -> None:
        return super()._set_field("reconciling",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "container_id":"container_id",
        "region":"region",
        "resource_affinity":"resource_affinity",
        "service":"service",
        "quantity":"quantity",
        "start_time":"start_time",
        "end_time":"end_time",
        "state":"state",
        "reconciling":"reconciling",
        "State":"State",
    }
    
class CapacityInterval(pb_classes.Message):
    """
    Capacity Intervals represents a timeframe during which the specified resources can be used.
    """
    
    __PB2_CLASS__ = capacity_interval_pb2.CapacityInterval
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.capacity.v1.CapacityInterval",capacity_interval_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "CapacityIntervalSpec|capacity_interval_pb2.CapacityIntervalSpec|None|unset.UnsetType" = unset.Unset,
        status: "CapacityIntervalStatus|capacity_interval_pb2.CapacityIntervalStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "CapacityIntervalSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=CapacityIntervalSpec,
        )
    @spec.setter
    def spec(self, value: "CapacityIntervalSpec|capacity_interval_pb2.CapacityIntervalSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "CapacityIntervalStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=CapacityIntervalStatus,
        )
    @status.setter
    def status(self, value: "CapacityIntervalStatus|capacity_interval_pb2.CapacityIntervalStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
# file: nebius/capacity/v1/capacity_interval_service.proto
class GetCapacityIntervalRequest(pb_classes.Message):
    """
    Getting Capacity Interval by its ID.
    """
    
    __PB2_CLASS__ = capacity_interval_service_pb2.GetCapacityIntervalRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.capacity.v1.GetCapacityIntervalRequest",capacity_interval_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListCapacityIntervalsRequest(pb_classes.Message):
    """
    Listing all existing Capacity Intervals in a Capacity Block Group.
    """
    
    __PB2_CLASS__ = capacity_interval_service_pb2.ListCapacityIntervalsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.capacity.v1.ListCapacityIntervalsRequest",capacity_interval_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        Capacity Block Group ID for which the Capacity Intervals should be listed.
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Page size. Must be between [1...200].
        Optional; if not specified, a reasonable default will be chosen by the service.
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Listing continuation token. Pass an empty string to start listing from the first page.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
    }
    
class ListCapacityIntervalsResponse(pb_classes.Message):
    """
    All existing Capacity Intervals in a Capacity Block Group.
    """
    
    __PB2_CLASS__ = capacity_interval_service_pb2.ListCapacityIntervalsResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.capacity.v1.ListCapacityIntervalsResponse",capacity_interval_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[CapacityInterval]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[CapacityInterval]":
        """
        List of Capacity Intervals on this result page.
        """
        
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(CapacityInterval,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[CapacityInterval]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        """
        Listing continuation token for the next page of results.
        """
        
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    

class CapacityIntervalServiceClient(client.Client):
    """
    Capacity Interval service provides read access to Capacity Intervals resources.
    
    This class provides the client methods for the ``.nebius.capacity.v1.CapacityIntervalService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.capacity.v1.CapacityIntervalService",capacity_interval_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.capacity.v1.CapacityIntervalService"
    
    def get(self,
        request: "GetCapacityIntervalRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request.Request["GetCapacityIntervalRequest","CapacityInterval"]:
        """
        Get Capacity Interval by its ID.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.capacity.v1.GetCapacityIntervalRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.capacity.v1.CapacityInterval`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=capacity_interval_pb2.CapacityInterval,
            result_wrapper=pb_classes.simple_wrapper(CapacityInterval),
            **kwargs,
        )
    
    def list(self,
        request: "ListCapacityIntervalsRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request.Request["ListCapacityIntervalsRequest","ListCapacityIntervalsResponse"]:
        """
        List all capacity intervals in a Capacity Block Group.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.capacity.v1.ListCapacityIntervalsRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.capacity.v1.ListCapacityIntervalsResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=capacity_interval_service_pb2.ListCapacityIntervalsResponse,
            result_wrapper=pb_classes.simple_wrapper(ListCapacityIntervalsResponse),
            **kwargs,
        )
    

__all__ = [
    #@ local import names here @#
    "ResourceAffinityComputeV1",
    "ResourceAffinity",
    "CapacityBlockGroupSpec",
    "CurrentContinuousInterval",
    "CapacityBlockGroupStatus",
    "CapacityBlockGroup",
    "GetCapacityBlockGroupRequest",
    "GetCapacityBlockGroupByResourceAffinityRequest",
    "ListCapacityBlockGroupsRequest",
    "ListCapacityBlockGroupsResponse",
    "ListCapacityBlockGroupResourcesRequest",
    "ListCapacityBlockGroupResourcesResponse",
    "CapacityBlockGroupServiceClient",
    "CapacityIntervalSpec",
    "CapacityIntervalStatus",
    "CapacityInterval",
    "GetCapacityIntervalRequest",
    "ListCapacityIntervalsRequest",
    "ListCapacityIntervalsResponse",
    "CapacityIntervalServiceClient",
]
