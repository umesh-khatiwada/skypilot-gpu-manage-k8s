# 
# Generated by the nebius.base.protos.compiler.  DO NOT EDIT!
# 

"""Auto-generated Nebius SDK package for ``nebius.ai.v1``"""

import builtins as builtins
import collections.abc as abc
import datetime as datetime
import google.protobuf.descriptor as descriptor_1
import google.protobuf.duration_pb2 as duration_pb2
import google.protobuf.message as message_1
import nebius.aio.client as client
import nebius.aio.operation as operation
import nebius.aio.request as request_1
import nebius.aio.request_kwargs as request_kwargs
import nebius.api.nebius.ai.v1.endpoint_pb2 as endpoint_pb2
import nebius.api.nebius.ai.v1.endpoint_service_pb2 as endpoint_service_pb2
import nebius.api.nebius.ai.v1.job_pb2 as job_pb2
import nebius.api.nebius.ai.v1.job_service_pb2 as job_service_pb2
import nebius.api.nebius.common.v1 as v1_1
import nebius.api.nebius.common.v1.metadata_pb2 as metadata_pb2
import nebius.api.nebius.common.v1.operation_pb2 as operation_pb2
import nebius.api.nebius.compute.v1 as v1_2
import nebius.api.nebius.compute.v1.disk_pb2 as disk_pb2
import nebius.api.nebius.compute.v1.instance_pb2 as instance_pb2
import nebius.base.fieldmask_protobuf as fieldmask_protobuf
import nebius.base.protos.descriptor as descriptor
import nebius.base.protos.pb_classes as pb_classes
import nebius.base.protos.pb_enum as pb_enum
import nebius.base.protos.unset as unset
import nebius.base.protos.well_known as well_known_1
import typing_extensions as typing_extensions
#@ local imports here @#

# file: nebius/ai/v1/endpoint.proto
class Endpoint(pb_classes.Message):
    """
    Represents an endpoint with a specified workload.
    """
    
    __PB2_CLASS__ = endpoint_pb2.Endpoint
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.ai.v1.Endpoint",endpoint_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "EndpointSpec|endpoint_pb2.EndpointSpec|None|unset.UnsetType" = unset.Unset,
        status: "EndpointStatus|endpoint_pb2.EndpointStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "EndpointSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=EndpointSpec,
        )
    @spec.setter
    def spec(self, value: "EndpointSpec|endpoint_pb2.EndpointSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "EndpointStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=EndpointStatus,
        )
    @status.setter
    def status(self, value: "EndpointStatus|endpoint_pb2.EndpointStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class EndpointSpec(pb_classes.Message):
    """
    EndpointSpec defines a endpoint that will be run.
    """
    
    __PB2_CLASS__ = endpoint_pb2.EndpointSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.ai.v1.EndpointSpec",endpoint_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class EnvironmentVariable(pb_classes.Message):
        """
        EnvironmentVariable defines an environment variable for the endpoint's container.
        """
        
        __PB2_CLASS__ = endpoint_pb2.EndpointSpec.EnvironmentVariable
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.ai.v1.EndpointSpec.EnvironmentVariable",endpoint_pb2.DESCRIPTOR,descriptor_1.Descriptor)
        __mask_functions__ = {
        }
        
        def __init__(
            self,
            initial_message: message_1.Message|None = None,
            *,
            name: "builtins.str|None|unset.UnsetType" = unset.Unset,
            value: "builtins.str|None|unset.UnsetType" = unset.Unset,
        ) -> None:
            super().__init__(initial_message)
            if not isinstance(name, unset.UnsetType):
                self.name = name
            if not isinstance(value, unset.UnsetType):
                self.value = value
        
        def __dir__(self) ->abc.Iterable[builtins.str]:
            return [
                "name",
                "value",
            ]
        
        @builtins.property
        def name(self) -> "builtins.str":
            """
            The name of the environment variable.
            """
            
            return super()._get_field("name", explicit_presence=False,
            )
        @name.setter
        def name(self, value: "builtins.str|None") -> None:
            return super()._set_field("name",value,explicit_presence=False,
            )
        
        @builtins.property
        def value(self) -> "builtins.str":
            """
            Environment variable value.
            """
            
            return super()._get_field("value", explicit_presence=False,
            )
        @value.setter
        def value(self, value: "builtins.str|None") -> None:
            return super()._set_field("value",value,explicit_presence=False,
            )
        
        __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
            "name":"name",
            "value":"value",
        }
        
    
    class Port(pb_classes.Message):
        __PB2_CLASS__ = endpoint_pb2.EndpointSpec.Port
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.ai.v1.EndpointSpec.Port",endpoint_pb2.DESCRIPTOR,descriptor_1.Descriptor)
        __mask_functions__ = {
        }
        
        class Protocol(pb_enum.Enum):
            """
            Represents protocol of the endpoint's port which will be exposed.
            """
            
            __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.ai.v1.EndpointSpec.Port.Protocol",endpoint_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
            PROTOCOL_UNSPECIFIED = 0
            HTTP = 1
            """
            HTTP protocol.
            """
            
            TCP = 2
            """
            TCP protocol.
            """
            
            UDP = 3
            """
            UDP protocol.
            """
            
        
        def __init__(
            self,
            initial_message: message_1.Message|None = None,
            *,
            container_port: "builtins.int|None|unset.UnsetType" = unset.Unset,
            host_port: "builtins.int|None|unset.UnsetType" = unset.Unset,
            protocol: "EndpointSpec.Port.Protocol|endpoint_pb2.EndpointSpec.Port.Protocol|None|unset.UnsetType" = unset.Unset,
        ) -> None:
            super().__init__(initial_message)
            if not isinstance(container_port, unset.UnsetType):
                self.container_port = container_port
            if not isinstance(host_port, unset.UnsetType):
                self.host_port = host_port
            if not isinstance(protocol, unset.UnsetType):
                self.protocol = protocol
        
        def __dir__(self) ->abc.Iterable[builtins.str]:
            return [
                "container_port",
                "host_port",
                "protocol",
                "Protocol",
            ]
        
        @builtins.property
        def container_port(self) -> "builtins.int":
            """
            Container port.
            """
            
            return super()._get_field("container_port", explicit_presence=False,
            )
        @container_port.setter
        def container_port(self, value: "builtins.int|None") -> None:
            return super()._set_field("container_port",value,explicit_presence=False,
            )
        
        @builtins.property
        def host_port(self) -> "builtins.int":
            """
            Host port.
            
            If not specified, will be same as container_port.
            """
            
            return super()._get_field("host_port", explicit_presence=False,
            )
        @host_port.setter
        def host_port(self, value: "builtins.int|None") -> None:
            return super()._set_field("host_port",value,explicit_presence=False,
            )
        
        @builtins.property
        def protocol(self) -> "EndpointSpec.Port.Protocol":
            """
            Port's protocol.
            """
            
            return super()._get_field("protocol", explicit_presence=False,
            wrap=EndpointSpec.Port.Protocol,
            )
        @protocol.setter
        def protocol(self, value: "EndpointSpec.Port.Protocol|endpoint_pb2.EndpointSpec.Port.Protocol|None") -> None:
            return super()._set_field("protocol",value,explicit_presence=False,
            )
        
        __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
            "container_port":"container_port",
            "host_port":"host_port",
            "protocol":"protocol",
            "Protocol":"Protocol",
        }
        
    
    class VolumeMount(pb_classes.Message):
        """
        VolumeMount represents a volume mount for the endpoint's container.
        """
        
        __PB2_CLASS__ = endpoint_pb2.EndpointSpec.VolumeMount
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.ai.v1.EndpointSpec.VolumeMount",endpoint_pb2.DESCRIPTOR,descriptor_1.Descriptor)
        __mask_functions__ = {
        }
        
        class Mode(pb_enum.Enum):
            """
            Mode that will be used to mount the volume.
            """
            
            __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.ai.v1.EndpointSpec.VolumeMount.Mode",endpoint_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
            MODE_UNSPECIFIED = 0
            READ_ONLY = 1
            """
            Read-only mode.
            """
            
            READ_WRITE = 2
            """
            Read-write mode.
            """
            
        
        def __init__(
            self,
            initial_message: message_1.Message|None = None,
            *,
            source: "builtins.str|None|unset.UnsetType" = unset.Unset,
            source_path: "builtins.str|None|unset.UnsetType" = unset.Unset,
            container_path: "builtins.str|None|unset.UnsetType" = unset.Unset,
            mode: "EndpointSpec.VolumeMount.Mode|endpoint_pb2.EndpointSpec.VolumeMount.Mode|None|unset.UnsetType" = unset.Unset,
        ) -> None:
            super().__init__(initial_message)
            if not isinstance(source, unset.UnsetType):
                self.source = source
            if not isinstance(source_path, unset.UnsetType):
                self.source_path = source_path
            if not isinstance(container_path, unset.UnsetType):
                self.container_path = container_path
            if not isinstance(mode, unset.UnsetType):
                self.mode = mode
        
        def __dir__(self) ->abc.Iterable[builtins.str]:
            return [
                "source",
                "source_path",
                "container_path",
                "mode",
                "Mode",
            ]
        
        @builtins.property
        def source(self) -> "builtins.str":
            """
            Source of the volume mount.
            
            Can be a name of an ID of Nebius Storage bucket or filesystem.
            """
            
            return super()._get_field("source", explicit_presence=False,
            )
        @source.setter
        def source(self, value: "builtins.str|None") -> None:
            return super()._set_field("source",value,explicit_presence=False,
            )
        
        @builtins.property
        def source_path(self) -> "builtins.str":
            """
            Path inside the source volume.
            
            Optional.
            """
            
            return super()._get_field("source_path", explicit_presence=False,
            )
        @source_path.setter
        def source_path(self, value: "builtins.str|None") -> None:
            return super()._set_field("source_path",value,explicit_presence=False,
            )
        
        @builtins.property
        def container_path(self) -> "builtins.str":
            """
            Path inside the endpoint's container where the volume is mounted.
            
            Must be an absolute path.
            """
            
            return super()._get_field("container_path", explicit_presence=False,
            )
        @container_path.setter
        def container_path(self, value: "builtins.str|None") -> None:
            return super()._set_field("container_path",value,explicit_presence=False,
            )
        
        @builtins.property
        def mode(self) -> "EndpointSpec.VolumeMount.Mode":
            """
            Mount mode.
            """
            
            return super()._get_field("mode", explicit_presence=False,
            wrap=EndpointSpec.VolumeMount.Mode,
            )
        @mode.setter
        def mode(self, value: "EndpointSpec.VolumeMount.Mode|endpoint_pb2.EndpointSpec.VolumeMount.Mode|None") -> None:
            return super()._set_field("mode",value,explicit_presence=False,
            )
        
        __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
            "source":"source",
            "source_path":"source_path",
            "container_path":"container_path",
            "mode":"mode",
            "Mode":"Mode",
        }
        
    
    class DiskSpec(pb_classes.Message):
        __PB2_CLASS__ = endpoint_pb2.EndpointSpec.DiskSpec
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.ai.v1.EndpointSpec.DiskSpec",endpoint_pb2.DESCRIPTOR,descriptor_1.Descriptor)
        __mask_functions__ = {
        }
        
        def __init__(
            self,
            initial_message: message_1.Message|None = None,
            *,
            type: "v1_2.DiskSpec.DiskType|disk_pb2.DiskSpec.DiskType|None|unset.UnsetType" = unset.Unset,
            size_bytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        ) -> None:
            super().__init__(initial_message)
            if not isinstance(type, unset.UnsetType):
                self.type = type
            if not isinstance(size_bytes, unset.UnsetType):
                self.size_bytes = size_bytes
        
        def __dir__(self) ->abc.Iterable[builtins.str]:
            return [
                "type",
                "size_bytes",
            ]
        
        @builtins.property
        def type(self) -> "v1_2.DiskSpec.DiskType":
            """
            Disk type.
            """
            
            return super()._get_field("type", explicit_presence=False,
            wrap=v1_2.DiskSpec.DiskType,
            )
        @type.setter
        def type(self, value: "v1_2.DiskSpec.DiskType|disk_pb2.DiskSpec.DiskType|None") -> None:
            return super()._set_field("type",value,explicit_presence=False,
            )
        
        @builtins.property
        def size_bytes(self) -> "builtins.int":
            """
            Disk size in bytes.
            """
            
            return super()._get_field("size_bytes", explicit_presence=False,
            )
        @size_bytes.setter
        def size_bytes(self, value: "builtins.int|None") -> None:
            return super()._set_field("size_bytes",value,explicit_presence=False,
            )
        
        __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
            "type":"type",
            "size_bytes":"size_bytes",
        }
        
    
    class RegistryCredentials(pb_classes.Message):
        __PB2_CLASS__ = endpoint_pb2.EndpointSpec.RegistryCredentials
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.ai.v1.EndpointSpec.RegistryCredentials",endpoint_pb2.DESCRIPTOR,descriptor_1.Descriptor)
        __mask_functions__ = {
        }
        
        def __init__(
            self,
            initial_message: message_1.Message|None = None,
            *,
            username: "builtins.str|None|unset.UnsetType" = unset.Unset,
            password: "builtins.str|None|unset.UnsetType" = unset.Unset,
            mysterybox_secret_version: "builtins.str|None|unset.UnsetType" = unset.Unset,
        ) -> None:
            super().__init__(initial_message)
            if not isinstance(username, unset.UnsetType):
                self.username = username
            if not isinstance(password, unset.UnsetType):
                self.password = password
            if not isinstance(mysterybox_secret_version, unset.UnsetType):
                self.mysterybox_secret_version = mysterybox_secret_version
        
        def __dir__(self) ->abc.Iterable[builtins.str]:
            return [
                "username",
                "password",
                "mysterybox_secret_version",
            ]
        
        @builtins.property
        def username(self) -> "builtins.str":
            """
            Registry username for private Docker registry.
            """
            
            return super()._get_field("username", explicit_presence=False,
            )
        @username.setter
        def username(self, value: "builtins.str|None") -> None:
            return super()._set_field("username",value,explicit_presence=False,
            )
        
        @builtins.property
        def password(self) -> "builtins.str":
            """
            Registry password for private Docker registry.
            """
            
            return super()._get_field("password", explicit_presence=False,
            )
        @password.setter
        def password(self, value: "builtins.str|None") -> None:
            return super()._set_field("password",value,explicit_presence=False,
            )
        
        @builtins.property
        def mysterybox_secret_version(self) -> "builtins.str":
            """
            Secret version storing the registry credentials.
            Must have keys "REGISTRY_USERNAME" and "REGISTRY_PASSWORD".
            """
            
            return super()._get_field("mysterybox_secret_version", explicit_presence=False,
            )
        @mysterybox_secret_version.setter
        def mysterybox_secret_version(self, value: "builtins.str|None") -> None:
            return super()._set_field("mysterybox_secret_version",value,explicit_presence=False,
            )
        
        __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
            "username":"username",
            "password":"password",
            "mysterybox_secret_version":"mysterybox_secret_version",
        }
        
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        image: "builtins.str|None|unset.UnsetType" = unset.Unset,
        environment_variables: "abc.Iterable[EndpointSpec.EnvironmentVariable]|None|unset.UnsetType" = unset.Unset,
        ports: "abc.Iterable[EndpointSpec.Port]|None|unset.UnsetType" = unset.Unset,
        container_command: "builtins.str|None|unset.UnsetType" = unset.Unset,
        args: "builtins.str|None|unset.UnsetType" = unset.Unset,
        working_dir: "builtins.str|None|unset.UnsetType" = unset.Unset,
        volumes: "abc.Iterable[EndpointSpec.VolumeMount]|None|unset.UnsetType" = unset.Unset,
        registry_credentials: "EndpointSpec.RegistryCredentials|endpoint_pb2.EndpointSpec.RegistryCredentials|None|unset.UnsetType" = unset.Unset,
        platform: "builtins.str|None|unset.UnsetType" = unset.Unset,
        preset: "builtins.str|None|unset.UnsetType" = unset.Unset,
        shm_size_bytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        disk: "EndpointSpec.DiskSpec|endpoint_pb2.EndpointSpec.DiskSpec|None|unset.UnsetType" = unset.Unset,
        subnet_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        public_ip: "builtins.bool|None|unset.UnsetType" = unset.Unset,
        ssh_authorized_keys: "abc.Iterable[builtins.str]|None|unset.UnsetType" = unset.Unset,
        auth_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(image, unset.UnsetType):
            self.image = image
        if not isinstance(environment_variables, unset.UnsetType):
            self.environment_variables = environment_variables
        if not isinstance(ports, unset.UnsetType):
            self.ports = ports
        if not isinstance(container_command, unset.UnsetType):
            self.container_command = container_command
        if not isinstance(args, unset.UnsetType):
            self.args = args
        if not isinstance(working_dir, unset.UnsetType):
            self.working_dir = working_dir
        if not isinstance(volumes, unset.UnsetType):
            self.volumes = volumes
        if not isinstance(registry_credentials, unset.UnsetType):
            self.registry_credentials = registry_credentials
        if not isinstance(platform, unset.UnsetType):
            self.platform = platform
        if not isinstance(preset, unset.UnsetType):
            self.preset = preset
        if not isinstance(shm_size_bytes, unset.UnsetType):
            self.shm_size_bytes = shm_size_bytes
        if not isinstance(disk, unset.UnsetType):
            self.disk = disk
        if not isinstance(subnet_id, unset.UnsetType):
            self.subnet_id = subnet_id
        if not isinstance(public_ip, unset.UnsetType):
            self.public_ip = public_ip
        if not isinstance(ssh_authorized_keys, unset.UnsetType):
            self.ssh_authorized_keys = ssh_authorized_keys
        if not isinstance(auth_token, unset.UnsetType):
            self.auth_token = auth_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "image",
            "environment_variables",
            "ports",
            "container_command",
            "args",
            "working_dir",
            "volumes",
            "registry_credentials",
            "platform",
            "preset",
            "shm_size_bytes",
            "disk",
            "subnet_id",
            "public_ip",
            "ssh_authorized_keys",
            "auth_token",
            "EnvironmentVariable",
            "Port",
            "VolumeMount",
            "DiskSpec",
            "RegistryCredentials",
        ]
    
    @builtins.property
    def image(self) -> "builtins.str":
        """
        The Docker image to use for the endpoint's container.
        """
        
        return super()._get_field("image", explicit_presence=False,
        )
    @image.setter
    def image(self, value: "builtins.str|None") -> None:
        return super()._set_field("image",value,explicit_presence=False,
        )
    
    @builtins.property
    def environment_variables(self) -> "abc.MutableSequence[EndpointSpec.EnvironmentVariable]":
        """
        Specifies the environment variables for the endpoint's container.
        """
        
        return super()._get_field("environment_variables", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(EndpointSpec.EnvironmentVariable,None,None),
        )
    @environment_variables.setter
    def environment_variables(self, value: "abc.Iterable[EndpointSpec.EnvironmentVariable]|None") -> None:
        return super()._set_field("environment_variables",value,explicit_presence=False,
        )
    
    @builtins.property
    def ports(self) -> "abc.MutableSequence[EndpointSpec.Port]":
        """
        Specifies the ports that the endpoint exposes.
        """
        
        return super()._get_field("ports", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(EndpointSpec.Port,None,None),
        )
    @ports.setter
    def ports(self, value: "abc.Iterable[EndpointSpec.Port]|None") -> None:
        return super()._set_field("ports",value,explicit_presence=False,
        )
    
    @builtins.property
    def container_command(self) -> "builtins.str":
        """
        The entrypoint command for the endpoint's container.
        """
        
        return super()._get_field("container_command", explicit_presence=False,
        )
    @container_command.setter
    def container_command(self, value: "builtins.str|None") -> None:
        return super()._set_field("container_command",value,explicit_presence=False,
        )
    
    @builtins.property
    def args(self) -> "builtins.str":
        """
        The arguments to pass to the entrypoint command.
        """
        
        return super()._get_field("args", explicit_presence=False,
        )
    @args.setter
    def args(self, value: "builtins.str|None") -> None:
        return super()._set_field("args",value,explicit_presence=False,
        )
    
    @builtins.property
    def working_dir(self) -> "builtins.str":
        """
        The working directory for the endpoint's container.
        """
        
        return super()._get_field("working_dir", explicit_presence=False,
        )
    @working_dir.setter
    def working_dir(self, value: "builtins.str|None") -> None:
        return super()._set_field("working_dir",value,explicit_presence=False,
        )
    
    @builtins.property
    def volumes(self) -> "abc.MutableSequence[EndpointSpec.VolumeMount]":
        """
        Volumes to be mounted into the endpoint's container.
        """
        
        return super()._get_field("volumes", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(EndpointSpec.VolumeMount,None,None),
        )
    @volumes.setter
    def volumes(self, value: "abc.Iterable[EndpointSpec.VolumeMount]|None") -> None:
        return super()._set_field("volumes",value,explicit_presence=False,
        )
    
    @builtins.property
    def registry_credentials(self) -> "EndpointSpec.RegistryCredentials":
        """
        Registry credentials for private Docker registry.
        """
        
        return super()._get_field("registry_credentials", explicit_presence=False,
        wrap=EndpointSpec.RegistryCredentials,
        )
    @registry_credentials.setter
    def registry_credentials(self, value: "EndpointSpec.RegistryCredentials|endpoint_pb2.EndpointSpec.RegistryCredentials|None") -> None:
        return super()._set_field("registry_credentials",value,explicit_presence=False,
        )
    
    @builtins.property
    def platform(self) -> "builtins.str":
        """
        Compute platform that the endpoint will be run on.
        """
        
        return super()._get_field("platform", explicit_presence=False,
        )
    @platform.setter
    def platform(self, value: "builtins.str|None") -> None:
        return super()._set_field("platform",value,explicit_presence=False,
        )
    
    @builtins.property
    def preset(self) -> "builtins.str":
        """
        Compute preset that the endpoint will be run on.
        """
        
        return super()._get_field("preset", explicit_presence=False,
        )
    @preset.setter
    def preset(self, value: "builtins.str|None") -> None:
        return super()._set_field("preset",value,explicit_presence=False,
        )
    
    @builtins.property
    def shm_size_bytes(self) -> "builtins.int":
        """
        Shared memory size in bytes for the endpoint's container.
        """
        
        return super()._get_field("shm_size_bytes", explicit_presence=False,
        )
    @shm_size_bytes.setter
    def shm_size_bytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("shm_size_bytes",value,explicit_presence=False,
        )
    
    @builtins.property
    def disk(self) -> "EndpointSpec.DiskSpec":
        """
        Disk spec for the main disk of the endpoint.
        """
        
        return super()._get_field("disk", explicit_presence=False,
        wrap=EndpointSpec.DiskSpec,
        )
    @disk.setter
    def disk(self, value: "EndpointSpec.DiskSpec|endpoint_pb2.EndpointSpec.DiskSpec|None") -> None:
        return super()._set_field("disk",value,explicit_presence=False,
        )
    
    @builtins.property
    def subnet_id(self) -> "builtins.str":
        """
        Subnet ID where the endpoint will be deployed.
        """
        
        return super()._get_field("subnet_id", explicit_presence=False,
        )
    @subnet_id.setter
    def subnet_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("subnet_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def public_ip(self) -> "builtins.bool":
        """
        Whether to assign a public IP to the endpoint.
        """
        
        return super()._get_field("public_ip", explicit_presence=False,
        )
    @public_ip.setter
    def public_ip(self, value: "builtins.bool|None") -> None:
        return super()._set_field("public_ip",value,explicit_presence=False,
        )
    
    @builtins.property
    def ssh_authorized_keys(self) -> "abc.MutableSequence[builtins.str]":
        """
        Public keys to be authorized for SSH access to the job.
        """
        
        return super()._get_field("ssh_authorized_keys", explicit_presence=False,
        wrap=pb_classes.Repeated,
        )
    @ssh_authorized_keys.setter
    def ssh_authorized_keys(self, value: "abc.Iterable[builtins.str]|None") -> None:
        return super()._set_field("ssh_authorized_keys",value,explicit_presence=False,
        )
    
    @builtins.property
    def auth_token(self) -> "builtins.str":
        """
        Authentication token needed to access the endpoint.
        
        Authentication can only be enabled if the endpoint exposes one and only one HTTP port.
        
        If not provided, a authentication will be disabled.
        """
        
        return super()._get_field("auth_token", explicit_presence=False,
        )
    @auth_token.setter
    def auth_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("auth_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "image":"image",
        "environment_variables":"environment_variables",
        "ports":"ports",
        "container_command":"container_command",
        "args":"args",
        "working_dir":"working_dir",
        "volumes":"volumes",
        "registry_credentials":"registry_credentials",
        "platform":"platform",
        "preset":"preset",
        "shm_size_bytes":"shm_size_bytes",
        "disk":"disk",
        "subnet_id":"subnet_id",
        "public_ip":"public_ip",
        "ssh_authorized_keys":"ssh_authorized_keys",
        "auth_token":"auth_token",
        "EnvironmentVariable":"EnvironmentVariable",
        "Port":"Port",
        "VolumeMount":"VolumeMount",
        "DiskSpec":"DiskSpec",
        "RegistryCredentials":"RegistryCredentials",
    }
    
class EndpointStatus(pb_classes.Message):
    """
    EndpointStatus represents the status of a VM app.
    """
    
    __PB2_CLASS__ = endpoint_pb2.EndpointStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.ai.v1.EndpointStatus",endpoint_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class State(pb_enum.Enum):
        """
        Endpoint state.
        """
        
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.ai.v1.EndpointStatus.State",endpoint_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        STATE_UNSPECIFIED = 0
        PROVISIONING = 1
        """
        The endpoint is creating resources.
        """
        
        STARTING = 2
        """
        The endpoint is being started.
        """
        
        RUNNING = 3
        """
        The endpoint is running.
        """
        
        STOPPING = 4
        """
        The endpoint is being stopped.
        """
        
        DELETING = 5
        """
        The endpoint is being deleted.
        """
        
        STOPPED = 6
        """
        The endpoint has been stopped.
        """
        
        ERROR = 8
        """
        The endpoint encountered an error.
        """
        
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        private_endpoints: "abc.Iterable[builtins.str]|None|unset.UnsetType" = unset.Unset,
        public_endpoints: "abc.Iterable[builtins.str]|None|unset.UnsetType" = unset.Unset,
        instances: "abc.Iterable[EndpointInstanceStatus]|None|unset.UnsetType" = unset.Unset,
        state: "EndpointStatus.State|endpoint_pb2.EndpointStatus.State|None|unset.UnsetType" = unset.Unset,
        state_details: "EndpointStateDetails|endpoint_pb2.EndpointStateDetails|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(private_endpoints, unset.UnsetType):
            self.private_endpoints = private_endpoints
        if not isinstance(public_endpoints, unset.UnsetType):
            self.public_endpoints = public_endpoints
        if not isinstance(instances, unset.UnsetType):
            self.instances = instances
        if not isinstance(state, unset.UnsetType):
            self.state = state
        if not isinstance(state_details, unset.UnsetType):
            self.state_details = state_details
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "private_endpoints",
            "public_endpoints",
            "instances",
            "state",
            "state_details",
            "State",
        ]
    
    @builtins.property
    def private_endpoints(self) -> "abc.MutableSequence[builtins.str]":
        """
        Private endpoints to access the workload.
        """
        
        return super()._get_field("private_endpoints", explicit_presence=False,
        wrap=pb_classes.Repeated,
        )
    @private_endpoints.setter
    def private_endpoints(self, value: "abc.Iterable[builtins.str]|None") -> None:
        return super()._set_field("private_endpoints",value,explicit_presence=False,
        )
    
    @builtins.property
    def public_endpoints(self) -> "abc.MutableSequence[builtins.str]":
        """
        Public endpoints to access the workload.
        """
        
        return super()._get_field("public_endpoints", explicit_presence=False,
        wrap=pb_classes.Repeated,
        )
    @public_endpoints.setter
    def public_endpoints(self, value: "abc.Iterable[builtins.str]|None") -> None:
        return super()._set_field("public_endpoints",value,explicit_presence=False,
        )
    
    @builtins.property
    def instances(self) -> "abc.MutableSequence[EndpointInstanceStatus]":
        """
        Status of individual endpoint instances.
        """
        
        return super()._get_field("instances", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(EndpointInstanceStatus,None,None),
        )
    @instances.setter
    def instances(self, value: "abc.Iterable[EndpointInstanceStatus]|None") -> None:
        return super()._set_field("instances",value,explicit_presence=False,
        )
    
    @builtins.property
    def state(self) -> "EndpointStatus.State":
        """
        State of the endpoint.
        """
        
        return super()._get_field("state", explicit_presence=False,
        wrap=EndpointStatus.State,
        )
    @state.setter
    def state(self, value: "EndpointStatus.State|endpoint_pb2.EndpointStatus.State|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    @builtins.property
    def state_details(self) -> "EndpointStateDetails":
        """
        Details of the endpoint's state.
        """
        
        return super()._get_field("state_details", explicit_presence=False,
        wrap=EndpointStateDetails,
        )
    @state_details.setter
    def state_details(self, value: "EndpointStateDetails|endpoint_pb2.EndpointStateDetails|None") -> None:
        return super()._set_field("state_details",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "private_endpoints":"private_endpoints",
        "public_endpoints":"public_endpoints",
        "instances":"instances",
        "state":"state",
        "state_details":"state_details",
        "State":"State",
    }
    
class EndpointStateDetails(pb_classes.Message):
    """
    Endpoint state details.
    """
    
    __PB2_CLASS__ = endpoint_pb2.EndpointStateDetails
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.ai.v1.EndpointStateDetails",endpoint_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        code: "builtins.str|None|unset.UnsetType" = unset.Unset,
        message: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(code, unset.UnsetType):
            self.code = code
        if not isinstance(message, unset.UnsetType):
            self.message = message
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "code",
            "message",
        ]
    
    @builtins.property
    def code(self) -> "builtins.str":
        """
        Short state description.
        """
        
        return super()._get_field("code", explicit_presence=False,
        )
    @code.setter
    def code(self, value: "builtins.str|None") -> None:
        return super()._set_field("code",value,explicit_presence=False,
        )
    
    @builtins.property
    def message(self) -> "builtins.str":
        """
        Detailed human-readable description.
        """
        
        return super()._get_field("message", explicit_presence=False,
        )
    @message.setter
    def message(self, value: "builtins.str|None") -> None:
        return super()._set_field("message",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "code":"code",
        "message":"message",
    }
    
class EndpointInstanceStatus(pb_classes.Message):
    """
    EndpointInstanceStatus represents the status of a endpoint instance.
    """
    
    __PB2_CLASS__ = endpoint_pb2.EndpointInstanceStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.ai.v1.EndpointInstanceStatus",endpoint_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class State(pb_enum.Enum):
        """
        Endpoint instance state.
        """
        
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.ai.v1.EndpointInstanceStatus.State",endpoint_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        STATE_UNSPECIFIED = 0
        PROVISIONING = 1
        """
        The endpoint is creating resources.
        """
        
        STARTING = 2
        """
        The endpoint is being started.
        """
        
        RUNNING = 3
        """
        The endpoint is running.
        """
        
        STOPPING = 4
        """
        The endpoint is being stopped.
        """
        
        DELETING = 5
        """
        The endpoint is being deleted.
        """
        
        STOPPED = 6
        """
        The endpoint has been stopped.
        """
        
        FAILED = 7
        """
        The endpoint has failed.
        """
        
        ERROR = 8
        """
        The endpoint encountered an error.
        """
        
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        state: "EndpointInstanceStatus.State|endpoint_pb2.EndpointInstanceStatus.State|None|unset.UnsetType" = unset.Unset,
        compute_instance_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        compute_instance_state: "v1_2.InstanceStatus.InstanceState|instance_pb2.InstanceStatus.InstanceState|None|unset.UnsetType" = unset.Unset,
        private_ip: "builtins.str|None|unset.UnsetType" = unset.Unset,
        public_ip: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(state, unset.UnsetType):
            self.state = state
        if not isinstance(compute_instance_id, unset.UnsetType):
            self.compute_instance_id = compute_instance_id
        if not isinstance(compute_instance_state, unset.UnsetType):
            self.compute_instance_state = compute_instance_state
        if not isinstance(private_ip, unset.UnsetType):
            self.private_ip = private_ip
        if not isinstance(public_ip, unset.UnsetType):
            self.public_ip = public_ip
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "state",
            "compute_instance_id",
            "compute_instance_state",
            "private_ip",
            "public_ip",
            "State",
        ]
    
    @builtins.property
    def state(self) -> "EndpointInstanceStatus.State":
        """
        The current state of the endpoint's workload.
        """
        
        return super()._get_field("state", explicit_presence=False,
        wrap=EndpointInstanceStatus.State,
        )
    @state.setter
    def state(self, value: "EndpointInstanceStatus.State|endpoint_pb2.EndpointInstanceStatus.State|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    @builtins.property
    def compute_instance_id(self) -> "builtins.str":
        """
        ID of the compute instance running the endpoint.
        """
        
        return super()._get_field("compute_instance_id", explicit_presence=False,
        )
    @compute_instance_id.setter
    def compute_instance_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("compute_instance_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def compute_instance_state(self) -> "v1_2.InstanceStatus.InstanceState":
        """
        The current state of the compute instance.
        """
        
        return super()._get_field("compute_instance_state", explicit_presence=False,
        wrap=v1_2.InstanceStatus.InstanceState,
        )
    @compute_instance_state.setter
    def compute_instance_state(self, value: "v1_2.InstanceStatus.InstanceState|instance_pb2.InstanceStatus.InstanceState|None") -> None:
        return super()._set_field("compute_instance_state",value,explicit_presence=False,
        )
    
    @builtins.property
    def private_ip(self) -> "builtins.str":
        """
        Private IP address of the instance.
        """
        
        return super()._get_field("private_ip", explicit_presence=False,
        )
    @private_ip.setter
    def private_ip(self, value: "builtins.str|None") -> None:
        return super()._set_field("private_ip",value,explicit_presence=False,
        )
    
    @builtins.property
    def public_ip(self) -> "builtins.str":
        """
        Public IP address of the instance.
        """
        
        return super()._get_field("public_ip", explicit_presence=False,
        )
    @public_ip.setter
    def public_ip(self, value: "builtins.str|None") -> None:
        return super()._set_field("public_ip",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "state":"state",
        "compute_instance_id":"compute_instance_id",
        "compute_instance_state":"compute_instance_state",
        "private_ip":"private_ip",
        "public_ip":"public_ip",
        "State":"State",
    }
    
# file: nebius/ai/v1/endpoint_service.proto
class GetEndpointRequest(pb_classes.Message):
    __PB2_CLASS__ = endpoint_service_pb2.GetEndpointRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.ai.v1.GetEndpointRequest",endpoint_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class GetEndpointByNameRequest(pb_classes.Message):
    __PB2_CLASS__ = endpoint_service_pb2.GetEndpointByNameRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.ai.v1.GetEndpointByNameRequest",endpoint_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(name, unset.UnsetType):
            self.name = name
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "name",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def name(self) -> "builtins.str":
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "name":"name",
    }
    
class ListEndpointsRequest(pb_classes.Message):
    __PB2_CLASS__ = endpoint_service_pb2.ListEndpointsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.ai.v1.ListEndpointsRequest",endpoint_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
    }
    
class CreateEndpointRequest(pb_classes.Message):
    __PB2_CLASS__ = endpoint_service_pb2.CreateEndpointRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.ai.v1.CreateEndpointRequest",endpoint_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "EndpointSpec|endpoint_pb2.EndpointSpec|None|unset.UnsetType" = unset.Unset,
        dry_run: "builtins.bool|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(dry_run, unset.UnsetType):
            self.dry_run = dry_run
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "dry_run",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "EndpointSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=EndpointSpec,
        )
    @spec.setter
    def spec(self, value: "EndpointSpec|endpoint_pb2.EndpointSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def dry_run(self) -> "builtins.bool":
        """
        Dry run creation of the endpoint.
        """
        
        return super()._get_field("dry_run", explicit_presence=False,
        )
    @dry_run.setter
    def dry_run(self, value: "builtins.bool|None") -> None:
        return super()._set_field("dry_run",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "dry_run":"dry_run",
    }
    
class DeleteEndpointRequest(pb_classes.Message):
    __PB2_CLASS__ = endpoint_service_pb2.DeleteEndpointRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.ai.v1.DeleteEndpointRequest",endpoint_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class UpdateEndpointRequest(pb_classes.Message):
    __PB2_CLASS__ = endpoint_service_pb2.UpdateEndpointRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.ai.v1.UpdateEndpointRequest",endpoint_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "EndpointSpec|endpoint_pb2.EndpointSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "EndpointSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=EndpointSpec,
        )
    @spec.setter
    def spec(self, value: "EndpointSpec|endpoint_pb2.EndpointSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class StartEndpointRequest(pb_classes.Message):
    __PB2_CLASS__ = endpoint_service_pb2.StartEndpointRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.ai.v1.StartEndpointRequest",endpoint_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class StopEndpointRequest(pb_classes.Message):
    __PB2_CLASS__ = endpoint_service_pb2.StopEndpointRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.ai.v1.StopEndpointRequest",endpoint_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListEndpointsResponse(pb_classes.Message):
    __PB2_CLASS__ = endpoint_service_pb2.ListEndpointsResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.ai.v1.ListEndpointsResponse",endpoint_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[Endpoint]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[Endpoint]":
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Endpoint,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[Endpoint]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    

class EndpointServiceClient(client.ClientWithOperations[v1_1.Operation,v1_1.OperationServiceClient]):
    """
    Service to create/manage endpoints.
    
    This class provides the client methods for the ``.nebius.ai.v1.EndpointService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.ai.v1.EndpointService",endpoint_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.ai.v1.EndpointService"
    __operation_type__ = v1_1.Operation
    __operation_service_class__ = v1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def get(self,
        request: "GetEndpointRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["GetEndpointRequest","Endpoint"]:
        """
        Returns the specified endpoint.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.ai.v1.GetEndpointRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.ai.v1.Endpoint`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=endpoint_pb2.Endpoint,
            result_wrapper=pb_classes.simple_wrapper(Endpoint),
            **kwargs,
        )
    
    def get_by_name(self,
        request: "GetEndpointByNameRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["GetEndpointByNameRequest","Endpoint"]:
        """
        Returns the specified endpoint by name.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.ai.v1.GetEndpointByNameRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.ai.v1.Endpoint`.
        """
        
        return super().request(
            method="GetByName",
            request=request,
            result_pb2_class=endpoint_pb2.Endpoint,
            result_wrapper=pb_classes.simple_wrapper(Endpoint),
            **kwargs,
        )
    
    def list(self,
        request: "ListEndpointsRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["ListEndpointsRequest","ListEndpointsResponse"]:
        """
        Retrieves a list of endpoints.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.ai.v1.ListEndpointsRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.ai.v1.ListEndpointsResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=endpoint_service_pb2.ListEndpointsResponse,
            result_wrapper=pb_classes.simple_wrapper(ListEndpointsResponse),
            **kwargs,
        )
    
    def create(self,
        request: "CreateEndpointRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["CreateEndpointRequest","operation.Operation[v1_1.Operation]"]:
        """
        Creates an endpoint.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.ai.v1.CreateEndpointRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation.Operation,
            **kwargs,
        )
    
    def delete(self,
        request: "DeleteEndpointRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["DeleteEndpointRequest","operation.Operation[v1_1.Operation]"]:
        """
        Deletes an endpoint.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.ai.v1.DeleteEndpointRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation.Operation,
            **kwargs,
        )
    
    def update(self,
        request: "UpdateEndpointRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["UpdateEndpointRequest","operation.Operation[v1_1.Operation]"]:
        """
        Updates an endpoint.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.ai.v1.UpdateEndpointRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        kwargs['metadata'] = fieldmask_protobuf.ensure_reset_mask_in_metadata(request, kwargs.get('metadata', None))
        return super().request(
            method="Update",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation.Operation,
            **kwargs,
        )
    
    def start(self,
        request: "StartEndpointRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["StartEndpointRequest","operation.Operation[v1_1.Operation]"]:
        """
        Starts an endpoint.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.ai.v1.StartEndpointRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Start",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation.Operation,
            **kwargs,
        )
    
    def stop(self,
        request: "StopEndpointRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["StopEndpointRequest","operation.Operation[v1_1.Operation]"]:
        """
        Stops an endpoint.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.ai.v1.StopEndpointRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Stop",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation.Operation,
            **kwargs,
        )
    

# file: nebius/ai/v1/job.proto
class Job(pb_classes.Message):
    """
    Represents a job with a specified workload.
    """
    
    __PB2_CLASS__ = job_pb2.Job
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.ai.v1.Job",job_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "JobSpec|job_pb2.JobSpec|None|unset.UnsetType" = unset.Unset,
        status: "JobStatus|job_pb2.JobStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "JobSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=JobSpec,
        )
    @spec.setter
    def spec(self, value: "JobSpec|job_pb2.JobSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "JobStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=JobStatus,
        )
    @status.setter
    def status(self, value: "JobStatus|job_pb2.JobStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class JobSpec(pb_classes.Message):
    """
    JobSpec defines a job that will be run.
    """
    
    __PB2_CLASS__ = job_pb2.JobSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.ai.v1.JobSpec",job_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
        "timeout": well_known_1.duration_mask,
    }
    
    class EnvironmentVariable(pb_classes.Message):
        """
        EnvironmentVariable defines an environment variable for the endpoint's container.
        """
        
        __PB2_CLASS__ = job_pb2.JobSpec.EnvironmentVariable
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.ai.v1.JobSpec.EnvironmentVariable",job_pb2.DESCRIPTOR,descriptor_1.Descriptor)
        __mask_functions__ = {
        }
        
        def __init__(
            self,
            initial_message: message_1.Message|None = None,
            *,
            name: "builtins.str|None|unset.UnsetType" = unset.Unset,
            value: "builtins.str|None|unset.UnsetType" = unset.Unset,
        ) -> None:
            super().__init__(initial_message)
            if not isinstance(name, unset.UnsetType):
                self.name = name
            if not isinstance(value, unset.UnsetType):
                self.value = value
        
        def __dir__(self) ->abc.Iterable[builtins.str]:
            return [
                "name",
                "value",
            ]
        
        @builtins.property
        def name(self) -> "builtins.str":
            """
            The name of the environment variable.
            """
            
            return super()._get_field("name", explicit_presence=False,
            )
        @name.setter
        def name(self, value: "builtins.str|None") -> None:
            return super()._set_field("name",value,explicit_presence=False,
            )
        
        @builtins.property
        def value(self) -> "builtins.str":
            """
            Environment variable value.
            """
            
            return super()._get_field("value", explicit_presence=False,
            )
        @value.setter
        def value(self, value: "builtins.str|None") -> None:
            return super()._set_field("value",value,explicit_presence=False,
            )
        
        __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
            "name":"name",
            "value":"value",
        }
        
    
    class Port(pb_classes.Message):
        __PB2_CLASS__ = job_pb2.JobSpec.Port
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.ai.v1.JobSpec.Port",job_pb2.DESCRIPTOR,descriptor_1.Descriptor)
        __mask_functions__ = {
        }
        
        class Protocol(pb_enum.Enum):
            """
            Represents protocol of the job's port which will be exposed.
            """
            
            __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.ai.v1.JobSpec.Port.Protocol",job_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
            PROTOCOL_UNSPECIFIED = 0
            HTTP = 1
            """
            HTTP protocol.
            """
            
            TCP = 2
            """
            TCP protocol.
            """
            
            UDP = 3
            """
            UDP protocol.
            """
            
        
        def __init__(
            self,
            initial_message: message_1.Message|None = None,
            *,
            container_port: "builtins.int|None|unset.UnsetType" = unset.Unset,
            host_port: "builtins.int|None|unset.UnsetType" = unset.Unset,
            protocol: "JobSpec.Port.Protocol|job_pb2.JobSpec.Port.Protocol|None|unset.UnsetType" = unset.Unset,
        ) -> None:
            super().__init__(initial_message)
            if not isinstance(container_port, unset.UnsetType):
                self.container_port = container_port
            if not isinstance(host_port, unset.UnsetType):
                self.host_port = host_port
            if not isinstance(protocol, unset.UnsetType):
                self.protocol = protocol
        
        def __dir__(self) ->abc.Iterable[builtins.str]:
            return [
                "container_port",
                "host_port",
                "protocol",
                "Protocol",
            ]
        
        @builtins.property
        def container_port(self) -> "builtins.int":
            """
            Container port.
            """
            
            return super()._get_field("container_port", explicit_presence=False,
            )
        @container_port.setter
        def container_port(self, value: "builtins.int|None") -> None:
            return super()._set_field("container_port",value,explicit_presence=False,
            )
        
        @builtins.property
        def host_port(self) -> "builtins.int":
            """
            Host port.
            
            If not specified, will be same as container_port.
            """
            
            return super()._get_field("host_port", explicit_presence=False,
            )
        @host_port.setter
        def host_port(self, value: "builtins.int|None") -> None:
            return super()._set_field("host_port",value,explicit_presence=False,
            )
        
        @builtins.property
        def protocol(self) -> "JobSpec.Port.Protocol":
            """
            Port's protocol.
            """
            
            return super()._get_field("protocol", explicit_presence=False,
            wrap=JobSpec.Port.Protocol,
            )
        @protocol.setter
        def protocol(self, value: "JobSpec.Port.Protocol|job_pb2.JobSpec.Port.Protocol|None") -> None:
            return super()._set_field("protocol",value,explicit_presence=False,
            )
        
        __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
            "container_port":"container_port",
            "host_port":"host_port",
            "protocol":"protocol",
            "Protocol":"Protocol",
        }
        
    
    class VolumeMount(pb_classes.Message):
        """
        VolumeMount represents a volume mount for the endpoint's container.
        """
        
        __PB2_CLASS__ = job_pb2.JobSpec.VolumeMount
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.ai.v1.JobSpec.VolumeMount",job_pb2.DESCRIPTOR,descriptor_1.Descriptor)
        __mask_functions__ = {
        }
        
        class Mode(pb_enum.Enum):
            """
            Mode that will be used to mount the volume.
            """
            
            __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.ai.v1.JobSpec.VolumeMount.Mode",job_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
            MODE_UNSPECIFIED = 0
            READ_WRITE = 1
            """
            Read-write mode.
            """
            
            READ_ONLY = 2
            """
            Read-only mode.
            """
            
        
        def __init__(
            self,
            initial_message: message_1.Message|None = None,
            *,
            source: "builtins.str|None|unset.UnsetType" = unset.Unset,
            source_path: "builtins.str|None|unset.UnsetType" = unset.Unset,
            container_path: "builtins.str|None|unset.UnsetType" = unset.Unset,
            mode: "JobSpec.VolumeMount.Mode|job_pb2.JobSpec.VolumeMount.Mode|None|unset.UnsetType" = unset.Unset,
        ) -> None:
            super().__init__(initial_message)
            if not isinstance(source, unset.UnsetType):
                self.source = source
            if not isinstance(source_path, unset.UnsetType):
                self.source_path = source_path
            if not isinstance(container_path, unset.UnsetType):
                self.container_path = container_path
            if not isinstance(mode, unset.UnsetType):
                self.mode = mode
        
        def __dir__(self) ->abc.Iterable[builtins.str]:
            return [
                "source",
                "source_path",
                "container_path",
                "mode",
                "Mode",
            ]
        
        @builtins.property
        def source(self) -> "builtins.str":
            """
            Source of the volume mount.
            
            Can be a name of an ID of Nebius Storage bucket or filesystem.
            """
            
            return super()._get_field("source", explicit_presence=False,
            )
        @source.setter
        def source(self, value: "builtins.str|None") -> None:
            return super()._set_field("source",value,explicit_presence=False,
            )
        
        @builtins.property
        def source_path(self) -> "builtins.str":
            """
            Path inside the source volume.
            
            Optional.
            """
            
            return super()._get_field("source_path", explicit_presence=False,
            )
        @source_path.setter
        def source_path(self, value: "builtins.str|None") -> None:
            return super()._set_field("source_path",value,explicit_presence=False,
            )
        
        @builtins.property
        def container_path(self) -> "builtins.str":
            """
            Path inside the endpoint's container where the volume is mounted.
            
            Must be an absolute path.
            """
            
            return super()._get_field("container_path", explicit_presence=False,
            )
        @container_path.setter
        def container_path(self, value: "builtins.str|None") -> None:
            return super()._set_field("container_path",value,explicit_presence=False,
            )
        
        @builtins.property
        def mode(self) -> "JobSpec.VolumeMount.Mode":
            """
            Mount mode.
            """
            
            return super()._get_field("mode", explicit_presence=False,
            wrap=JobSpec.VolumeMount.Mode,
            )
        @mode.setter
        def mode(self, value: "JobSpec.VolumeMount.Mode|job_pb2.JobSpec.VolumeMount.Mode|None") -> None:
            return super()._set_field("mode",value,explicit_presence=False,
            )
        
        __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
            "source":"source",
            "source_path":"source_path",
            "container_path":"container_path",
            "mode":"mode",
            "Mode":"Mode",
        }
        
    
    class DiskSpec(pb_classes.Message):
        __PB2_CLASS__ = job_pb2.JobSpec.DiskSpec
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.ai.v1.JobSpec.DiskSpec",job_pb2.DESCRIPTOR,descriptor_1.Descriptor)
        __mask_functions__ = {
        }
        
        def __init__(
            self,
            initial_message: message_1.Message|None = None,
            *,
            type: "v1_2.DiskSpec.DiskType|disk_pb2.DiskSpec.DiskType|None|unset.UnsetType" = unset.Unset,
            size_bytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        ) -> None:
            super().__init__(initial_message)
            if not isinstance(type, unset.UnsetType):
                self.type = type
            if not isinstance(size_bytes, unset.UnsetType):
                self.size_bytes = size_bytes
        
        def __dir__(self) ->abc.Iterable[builtins.str]:
            return [
                "type",
                "size_bytes",
            ]
        
        @builtins.property
        def type(self) -> "v1_2.DiskSpec.DiskType":
            """
            Disk type.
            """
            
            return super()._get_field("type", explicit_presence=False,
            wrap=v1_2.DiskSpec.DiskType,
            )
        @type.setter
        def type(self, value: "v1_2.DiskSpec.DiskType|disk_pb2.DiskSpec.DiskType|None") -> None:
            return super()._set_field("type",value,explicit_presence=False,
            )
        
        @builtins.property
        def size_bytes(self) -> "builtins.int":
            """
            Disk size in bytes.
            """
            
            return super()._get_field("size_bytes", explicit_presence=False,
            )
        @size_bytes.setter
        def size_bytes(self, value: "builtins.int|None") -> None:
            return super()._set_field("size_bytes",value,explicit_presence=False,
            )
        
        __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
            "type":"type",
            "size_bytes":"size_bytes",
        }
        
    
    class RegistryCredentials(pb_classes.Message):
        __PB2_CLASS__ = job_pb2.JobSpec.RegistryCredentials
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.ai.v1.JobSpec.RegistryCredentials",job_pb2.DESCRIPTOR,descriptor_1.Descriptor)
        __mask_functions__ = {
        }
        
        def __init__(
            self,
            initial_message: message_1.Message|None = None,
            *,
            username: "builtins.str|None|unset.UnsetType" = unset.Unset,
            password: "builtins.str|None|unset.UnsetType" = unset.Unset,
            mysterybox_secret_version: "builtins.str|None|unset.UnsetType" = unset.Unset,
        ) -> None:
            super().__init__(initial_message)
            if not isinstance(username, unset.UnsetType):
                self.username = username
            if not isinstance(password, unset.UnsetType):
                self.password = password
            if not isinstance(mysterybox_secret_version, unset.UnsetType):
                self.mysterybox_secret_version = mysterybox_secret_version
        
        def __dir__(self) ->abc.Iterable[builtins.str]:
            return [
                "username",
                "password",
                "mysterybox_secret_version",
            ]
        
        @builtins.property
        def username(self) -> "builtins.str":
            """
            Registry username for private Docker registry.
            """
            
            return super()._get_field("username", explicit_presence=False,
            )
        @username.setter
        def username(self, value: "builtins.str|None") -> None:
            return super()._set_field("username",value,explicit_presence=False,
            )
        
        @builtins.property
        def password(self) -> "builtins.str":
            """
            Registry password for private Docker registry.
            """
            
            return super()._get_field("password", explicit_presence=False,
            )
        @password.setter
        def password(self, value: "builtins.str|None") -> None:
            return super()._set_field("password",value,explicit_presence=False,
            )
        
        @builtins.property
        def mysterybox_secret_version(self) -> "builtins.str":
            """
            Secret version storing the registry credentials.
            Must have keys "REGISTRY_USERNAME" and "REGISTRY_PASSWORD".
            """
            
            return super()._get_field("mysterybox_secret_version", explicit_presence=False,
            )
        @mysterybox_secret_version.setter
        def mysterybox_secret_version(self, value: "builtins.str|None") -> None:
            return super()._set_field("mysterybox_secret_version",value,explicit_presence=False,
            )
        
        __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
            "username":"username",
            "password":"password",
            "mysterybox_secret_version":"mysterybox_secret_version",
        }
        
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        image: "builtins.str|None|unset.UnsetType" = unset.Unset,
        environment_variables: "abc.Iterable[JobSpec.EnvironmentVariable]|None|unset.UnsetType" = unset.Unset,
        ports: "abc.Iterable[JobSpec.Port]|None|unset.UnsetType" = unset.Unset,
        container_command: "builtins.str|None|unset.UnsetType" = unset.Unset,
        args: "builtins.str|None|unset.UnsetType" = unset.Unset,
        working_dir: "builtins.str|None|unset.UnsetType" = unset.Unset,
        volumes: "abc.Iterable[JobSpec.VolumeMount]|None|unset.UnsetType" = unset.Unset,
        registry_credentials: "JobSpec.RegistryCredentials|job_pb2.JobSpec.RegistryCredentials|None|unset.UnsetType" = unset.Unset,
        platform: "builtins.str|None|unset.UnsetType" = unset.Unset,
        preset: "builtins.str|None|unset.UnsetType" = unset.Unset,
        shm_size_bytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        disk: "JobSpec.DiskSpec|job_pb2.JobSpec.DiskSpec|None|unset.UnsetType" = unset.Unset,
        subnet_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        public_ip: "builtins.bool|None|unset.UnsetType" = unset.Unset,
        ssh_authorized_keys: "abc.Iterable[builtins.str]|None|unset.UnsetType" = unset.Unset,
        restart_attempts: "builtins.int|None|unset.UnsetType" = unset.Unset,
        timeout: "duration_pb2.Duration|datetime.timedelta|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(image, unset.UnsetType):
            self.image = image
        if not isinstance(environment_variables, unset.UnsetType):
            self.environment_variables = environment_variables
        if not isinstance(ports, unset.UnsetType):
            self.ports = ports
        if not isinstance(container_command, unset.UnsetType):
            self.container_command = container_command
        if not isinstance(args, unset.UnsetType):
            self.args = args
        if not isinstance(working_dir, unset.UnsetType):
            self.working_dir = working_dir
        if not isinstance(volumes, unset.UnsetType):
            self.volumes = volumes
        if not isinstance(registry_credentials, unset.UnsetType):
            self.registry_credentials = registry_credentials
        if not isinstance(platform, unset.UnsetType):
            self.platform = platform
        if not isinstance(preset, unset.UnsetType):
            self.preset = preset
        if not isinstance(shm_size_bytes, unset.UnsetType):
            self.shm_size_bytes = shm_size_bytes
        if not isinstance(disk, unset.UnsetType):
            self.disk = disk
        if not isinstance(subnet_id, unset.UnsetType):
            self.subnet_id = subnet_id
        if not isinstance(public_ip, unset.UnsetType):
            self.public_ip = public_ip
        if not isinstance(ssh_authorized_keys, unset.UnsetType):
            self.ssh_authorized_keys = ssh_authorized_keys
        if not isinstance(restart_attempts, unset.UnsetType):
            self.restart_attempts = restart_attempts
        if not isinstance(timeout, unset.UnsetType):
            self.timeout = timeout
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "image",
            "environment_variables",
            "ports",
            "container_command",
            "args",
            "working_dir",
            "volumes",
            "registry_credentials",
            "platform",
            "preset",
            "shm_size_bytes",
            "disk",
            "subnet_id",
            "public_ip",
            "ssh_authorized_keys",
            "restart_attempts",
            "timeout",
            "EnvironmentVariable",
            "Port",
            "VolumeMount",
            "DiskSpec",
            "RegistryCredentials",
        ]
    
    @builtins.property
    def image(self) -> "builtins.str":
        """
        The Docker image to use for the job's container.
        """
        
        return super()._get_field("image", explicit_presence=False,
        )
    @image.setter
    def image(self, value: "builtins.str|None") -> None:
        return super()._set_field("image",value,explicit_presence=False,
        )
    
    @builtins.property
    def environment_variables(self) -> "abc.MutableSequence[JobSpec.EnvironmentVariable]":
        """
        Specifies the environment variables for the job's container.
        """
        
        return super()._get_field("environment_variables", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(JobSpec.EnvironmentVariable,None,None),
        )
    @environment_variables.setter
    def environment_variables(self, value: "abc.Iterable[JobSpec.EnvironmentVariable]|None") -> None:
        return super()._set_field("environment_variables",value,explicit_presence=False,
        )
    
    @builtins.property
    def ports(self) -> "abc.MutableSequence[JobSpec.Port]":
        """
        Specifies the ports that the job exposes.
        """
        
        return super()._get_field("ports", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(JobSpec.Port,None,None),
        )
    @ports.setter
    def ports(self, value: "abc.Iterable[JobSpec.Port]|None") -> None:
        return super()._set_field("ports",value,explicit_presence=False,
        )
    
    @builtins.property
    def container_command(self) -> "builtins.str":
        """
        The entrypoint command for the job's container.
        """
        
        return super()._get_field("container_command", explicit_presence=False,
        )
    @container_command.setter
    def container_command(self, value: "builtins.str|None") -> None:
        return super()._set_field("container_command",value,explicit_presence=False,
        )
    
    @builtins.property
    def args(self) -> "builtins.str":
        """
        The arguments to pass to the entrypoint command.
        """
        
        return super()._get_field("args", explicit_presence=False,
        )
    @args.setter
    def args(self, value: "builtins.str|None") -> None:
        return super()._set_field("args",value,explicit_presence=False,
        )
    
    @builtins.property
    def working_dir(self) -> "builtins.str":
        """
        The working directory for the job's container.
        """
        
        return super()._get_field("working_dir", explicit_presence=False,
        )
    @working_dir.setter
    def working_dir(self, value: "builtins.str|None") -> None:
        return super()._set_field("working_dir",value,explicit_presence=False,
        )
    
    @builtins.property
    def volumes(self) -> "abc.MutableSequence[JobSpec.VolumeMount]":
        """
        Volumes to be mounted into the job's container.
        """
        
        return super()._get_field("volumes", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(JobSpec.VolumeMount,None,None),
        )
    @volumes.setter
    def volumes(self, value: "abc.Iterable[JobSpec.VolumeMount]|None") -> None:
        return super()._set_field("volumes",value,explicit_presence=False,
        )
    
    @builtins.property
    def registry_credentials(self) -> "JobSpec.RegistryCredentials":
        """
        Registry credentials for private Docker registry.
        """
        
        return super()._get_field("registry_credentials", explicit_presence=False,
        wrap=JobSpec.RegistryCredentials,
        )
    @registry_credentials.setter
    def registry_credentials(self, value: "JobSpec.RegistryCredentials|job_pb2.JobSpec.RegistryCredentials|None") -> None:
        return super()._set_field("registry_credentials",value,explicit_presence=False,
        )
    
    @builtins.property
    def platform(self) -> "builtins.str":
        """
        Compute platform that the job will be run on.
        """
        
        return super()._get_field("platform", explicit_presence=False,
        )
    @platform.setter
    def platform(self, value: "builtins.str|None") -> None:
        return super()._set_field("platform",value,explicit_presence=False,
        )
    
    @builtins.property
    def preset(self) -> "builtins.str":
        """
        Compute preset that the job will be run on.
        """
        
        return super()._get_field("preset", explicit_presence=False,
        )
    @preset.setter
    def preset(self, value: "builtins.str|None") -> None:
        return super()._set_field("preset",value,explicit_presence=False,
        )
    
    @builtins.property
    def shm_size_bytes(self) -> "builtins.int":
        """
        Shared memory size in bytes for the job's container.
        """
        
        return super()._get_field("shm_size_bytes", explicit_presence=False,
        )
    @shm_size_bytes.setter
    def shm_size_bytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("shm_size_bytes",value,explicit_presence=False,
        )
    
    @builtins.property
    def disk(self) -> "JobSpec.DiskSpec":
        """
        Disk spec for the main disk of the job.
        """
        
        return super()._get_field("disk", explicit_presence=False,
        wrap=JobSpec.DiskSpec,
        )
    @disk.setter
    def disk(self, value: "JobSpec.DiskSpec|job_pb2.JobSpec.DiskSpec|None") -> None:
        return super()._set_field("disk",value,explicit_presence=False,
        )
    
    @builtins.property
    def subnet_id(self) -> "builtins.str":
        """
        Subnet ID where the job will be deployed.
        """
        
        return super()._get_field("subnet_id", explicit_presence=False,
        )
    @subnet_id.setter
    def subnet_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("subnet_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def public_ip(self) -> "builtins.bool":
        """
        Whether to assign a public IP to the job.
        """
        
        return super()._get_field("public_ip", explicit_presence=False,
        )
    @public_ip.setter
    def public_ip(self, value: "builtins.bool|None") -> None:
        return super()._set_field("public_ip",value,explicit_presence=False,
        )
    
    @builtins.property
    def ssh_authorized_keys(self) -> "abc.MutableSequence[builtins.str]":
        """
        Public keys to be authorized for SSH access to the job.
        """
        
        return super()._get_field("ssh_authorized_keys", explicit_presence=False,
        wrap=pb_classes.Repeated,
        )
    @ssh_authorized_keys.setter
    def ssh_authorized_keys(self, value: "abc.Iterable[builtins.str]|None") -> None:
        return super()._set_field("ssh_authorized_keys",value,explicit_presence=False,
        )
    
    @builtins.property
    def restart_attempts(self) -> "builtins.int":
        """
        Restart attempts for the job.
        """
        
        return super()._get_field("restart_attempts", explicit_presence=False,
        )
    @restart_attempts.setter
    def restart_attempts(self, value: "builtins.int|None") -> None:
        return super()._set_field("restart_attempts",value,explicit_presence=False,
        )
    
    @builtins.property
    def timeout(self) -> "datetime.timedelta":
        """
        Job timeout.
        """
        
        return super()._get_field("timeout", explicit_presence=False,
        wrap=well_known_1.from_duration
        )
    @timeout.setter
    def timeout(self, value: "duration_pb2.Duration|datetime.timedelta|None") -> None:
        return super()._set_field("timeout",value,explicit_presence=False,
        unwrap=well_known_1.to_duration
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "image":"image",
        "environment_variables":"environment_variables",
        "ports":"ports",
        "container_command":"container_command",
        "args":"args",
        "working_dir":"working_dir",
        "volumes":"volumes",
        "registry_credentials":"registry_credentials",
        "platform":"platform",
        "preset":"preset",
        "shm_size_bytes":"shm_size_bytes",
        "disk":"disk",
        "subnet_id":"subnet_id",
        "public_ip":"public_ip",
        "ssh_authorized_keys":"ssh_authorized_keys",
        "restart_attempts":"restart_attempts",
        "timeout":"timeout",
        "EnvironmentVariable":"EnvironmentVariable",
        "Port":"Port",
        "VolumeMount":"VolumeMount",
        "DiskSpec":"DiskSpec",
        "RegistryCredentials":"RegistryCredentials",
    }
    
class JobStatus(pb_classes.Message):
    """
    JobStatus represents the status of a VM app.
    """
    
    __PB2_CLASS__ = job_pb2.JobStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.ai.v1.JobStatus",job_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class State(pb_enum.Enum):
        """
        Job state.
        """
        
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.ai.v1.JobStatus.State",job_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        STATE_UNSPECIFIED = 0
        PROVISIONING = 1
        """
        The job is creating resources.
        """
        
        STARTING = 2
        """
        The job is being started.
        """
        
        RUNNING = 3
        """
        The job is running.
        """
        
        CANCELLING = 4
        """
        The job is being cancelled.
        """
        
        DELETING = 5
        """
        The job is being deleted.
        """
        
        COMPLETED = 6
        """
        The job has successfully completed.
        """
        
        FAILED = 7
        """
        The job has failed.
        """
        
        CANCELLED = 8
        """
        The job has been cancelled.
        """
        
        ERROR = 9
        """
        The job encountered an internal error.
        """
        
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        private_endpoints: "abc.Iterable[builtins.str]|None|unset.UnsetType" = unset.Unset,
        public_endpoints: "abc.Iterable[builtins.str]|None|unset.UnsetType" = unset.Unset,
        instances: "abc.Iterable[JobInstanceStatus]|None|unset.UnsetType" = unset.Unset,
        state: "JobStatus.State|job_pb2.JobStatus.State|None|unset.UnsetType" = unset.Unset,
        state_details: "JobStateDetails|job_pb2.JobStateDetails|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(private_endpoints, unset.UnsetType):
            self.private_endpoints = private_endpoints
        if not isinstance(public_endpoints, unset.UnsetType):
            self.public_endpoints = public_endpoints
        if not isinstance(instances, unset.UnsetType):
            self.instances = instances
        if not isinstance(state, unset.UnsetType):
            self.state = state
        if not isinstance(state_details, unset.UnsetType):
            self.state_details = state_details
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "private_endpoints",
            "public_endpoints",
            "instances",
            "state",
            "state_details",
            "State",
        ]
    
    @builtins.property
    def private_endpoints(self) -> "abc.MutableSequence[builtins.str]":
        """
        Private endpoints to access the workload.
        """
        
        return super()._get_field("private_endpoints", explicit_presence=False,
        wrap=pb_classes.Repeated,
        )
    @private_endpoints.setter
    def private_endpoints(self, value: "abc.Iterable[builtins.str]|None") -> None:
        return super()._set_field("private_endpoints",value,explicit_presence=False,
        )
    
    @builtins.property
    def public_endpoints(self) -> "abc.MutableSequence[builtins.str]":
        """
        Public endpoints to access the workload.
        """
        
        return super()._get_field("public_endpoints", explicit_presence=False,
        wrap=pb_classes.Repeated,
        )
    @public_endpoints.setter
    def public_endpoints(self, value: "abc.Iterable[builtins.str]|None") -> None:
        return super()._set_field("public_endpoints",value,explicit_presence=False,
        )
    
    @builtins.property
    def instances(self) -> "abc.MutableSequence[JobInstanceStatus]":
        """
        Status of individual job instances.
        """
        
        return super()._get_field("instances", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(JobInstanceStatus,None,None),
        )
    @instances.setter
    def instances(self, value: "abc.Iterable[JobInstanceStatus]|None") -> None:
        return super()._set_field("instances",value,explicit_presence=False,
        )
    
    @builtins.property
    def state(self) -> "JobStatus.State":
        """
        State of the job.
        """
        
        return super()._get_field("state", explicit_presence=False,
        wrap=JobStatus.State,
        )
    @state.setter
    def state(self, value: "JobStatus.State|job_pb2.JobStatus.State|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    @builtins.property
    def state_details(self) -> "JobStateDetails":
        """
        Details of the job's state.
        """
        
        return super()._get_field("state_details", explicit_presence=False,
        wrap=JobStateDetails,
        )
    @state_details.setter
    def state_details(self, value: "JobStateDetails|job_pb2.JobStateDetails|None") -> None:
        return super()._set_field("state_details",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "private_endpoints":"private_endpoints",
        "public_endpoints":"public_endpoints",
        "instances":"instances",
        "state":"state",
        "state_details":"state_details",
        "State":"State",
    }
    
class JobStateDetails(pb_classes.Message):
    """
    Job state details.
    """
    
    __PB2_CLASS__ = job_pb2.JobStateDetails
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.ai.v1.JobStateDetails",job_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        code: "builtins.str|None|unset.UnsetType" = unset.Unset,
        message: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(code, unset.UnsetType):
            self.code = code
        if not isinstance(message, unset.UnsetType):
            self.message = message
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "code",
            "message",
        ]
    
    @builtins.property
    def code(self) -> "builtins.str":
        """
        Short state description.
        """
        
        return super()._get_field("code", explicit_presence=False,
        )
    @code.setter
    def code(self, value: "builtins.str|None") -> None:
        return super()._set_field("code",value,explicit_presence=False,
        )
    
    @builtins.property
    def message(self) -> "builtins.str":
        """
        Detailed human-readable description.
        """
        
        return super()._get_field("message", explicit_presence=False,
        )
    @message.setter
    def message(self, value: "builtins.str|None") -> None:
        return super()._set_field("message",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "code":"code",
        "message":"message",
    }
    
class JobInstanceStatus(pb_classes.Message):
    """
    JobInstanceStatus represents the status of a job instance.
    """
    
    __PB2_CLASS__ = job_pb2.JobInstanceStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.ai.v1.JobInstanceStatus",job_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class State(pb_enum.Enum):
        """
        Job instance state.
        """
        
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.ai.v1.JobInstanceStatus.State",job_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        STATE_UNSPECIFIED = 0
        PROVISIONING = 1
        """
        The job is creating resources.
        """
        
        STARTING = 2
        """
        The job is being started.
        """
        
        RUNNING = 3
        """
        The job is running.
        """
        
        COMPLETING = 4
        """
        The job is completing.
        """
        
        CANCELLING = 5
        """
        The job is being cancelled.
        """
        
        DELETING = 6
        """
        The job is being deleted.
        """
        
        COMPLETED = 7
        """
        The job has successfully completed.
        """
        
        FAILED = 8
        """
        The job has failed.
        """
        
        CANCELLED = 9
        """
        The job has been cancelled.
        """
        
        ERROR = 10
        """
        The job encountered an internal error.
        """
        
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        state: "JobInstanceStatus.State|job_pb2.JobInstanceStatus.State|None|unset.UnsetType" = unset.Unset,
        compute_instance_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        compute_instance_state: "v1_2.InstanceStatus.InstanceState|instance_pb2.InstanceStatus.InstanceState|None|unset.UnsetType" = unset.Unset,
        private_ip: "builtins.str|None|unset.UnsetType" = unset.Unset,
        public_ip: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(state, unset.UnsetType):
            self.state = state
        if not isinstance(compute_instance_id, unset.UnsetType):
            self.compute_instance_id = compute_instance_id
        if not isinstance(compute_instance_state, unset.UnsetType):
            self.compute_instance_state = compute_instance_state
        if not isinstance(private_ip, unset.UnsetType):
            self.private_ip = private_ip
        if not isinstance(public_ip, unset.UnsetType):
            self.public_ip = public_ip
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "state",
            "compute_instance_id",
            "compute_instance_state",
            "private_ip",
            "public_ip",
            "State",
        ]
    
    @builtins.property
    def state(self) -> "JobInstanceStatus.State":
        """
        The current state of the job's workload.
        """
        
        return super()._get_field("state", explicit_presence=False,
        wrap=JobInstanceStatus.State,
        )
    @state.setter
    def state(self, value: "JobInstanceStatus.State|job_pb2.JobInstanceStatus.State|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    @builtins.property
    def compute_instance_id(self) -> "builtins.str":
        """
        ID of the compute instance running the job.
        """
        
        return super()._get_field("compute_instance_id", explicit_presence=False,
        )
    @compute_instance_id.setter
    def compute_instance_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("compute_instance_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def compute_instance_state(self) -> "v1_2.InstanceStatus.InstanceState":
        """
        The current state of the compute instance.
        """
        
        return super()._get_field("compute_instance_state", explicit_presence=False,
        wrap=v1_2.InstanceStatus.InstanceState,
        )
    @compute_instance_state.setter
    def compute_instance_state(self, value: "v1_2.InstanceStatus.InstanceState|instance_pb2.InstanceStatus.InstanceState|None") -> None:
        return super()._set_field("compute_instance_state",value,explicit_presence=False,
        )
    
    @builtins.property
    def private_ip(self) -> "builtins.str":
        """
        Private IP address of the instance.
        """
        
        return super()._get_field("private_ip", explicit_presence=False,
        )
    @private_ip.setter
    def private_ip(self, value: "builtins.str|None") -> None:
        return super()._set_field("private_ip",value,explicit_presence=False,
        )
    
    @builtins.property
    def public_ip(self) -> "builtins.str":
        """
        Public IP address of the instance.
        """
        
        return super()._get_field("public_ip", explicit_presence=False,
        )
    @public_ip.setter
    def public_ip(self, value: "builtins.str|None") -> None:
        return super()._set_field("public_ip",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "state":"state",
        "compute_instance_id":"compute_instance_id",
        "compute_instance_state":"compute_instance_state",
        "private_ip":"private_ip",
        "public_ip":"public_ip",
        "State":"State",
    }
    
# file: nebius/ai/v1/job_service.proto
class GetJobRequest(pb_classes.Message):
    __PB2_CLASS__ = job_service_pb2.GetJobRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.ai.v1.GetJobRequest",job_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class GetJobByNameRequest(pb_classes.Message):
    __PB2_CLASS__ = job_service_pb2.GetJobByNameRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.ai.v1.GetJobByNameRequest",job_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(name, unset.UnsetType):
            self.name = name
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "name",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def name(self) -> "builtins.str":
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "name":"name",
    }
    
class ListJobsRequest(pb_classes.Message):
    __PB2_CLASS__ = job_service_pb2.ListJobsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.ai.v1.ListJobsRequest",job_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
    }
    
class CreateJobRequest(pb_classes.Message):
    __PB2_CLASS__ = job_service_pb2.CreateJobRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.ai.v1.CreateJobRequest",job_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "JobSpec|job_pb2.JobSpec|None|unset.UnsetType" = unset.Unset,
        dry_run: "builtins.bool|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(dry_run, unset.UnsetType):
            self.dry_run = dry_run
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "dry_run",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "JobSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=JobSpec,
        )
    @spec.setter
    def spec(self, value: "JobSpec|job_pb2.JobSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def dry_run(self) -> "builtins.bool":
        """
        Dry run creation of the job.
        """
        
        return super()._get_field("dry_run", explicit_presence=False,
        )
    @dry_run.setter
    def dry_run(self, value: "builtins.bool|None") -> None:
        return super()._set_field("dry_run",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "dry_run":"dry_run",
    }
    
class DeleteJobRequest(pb_classes.Message):
    __PB2_CLASS__ = job_service_pb2.DeleteJobRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.ai.v1.DeleteJobRequest",job_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class CancelJobRequest(pb_classes.Message):
    __PB2_CLASS__ = job_service_pb2.CancelJobRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.ai.v1.CancelJobRequest",job_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListJobsResponse(pb_classes.Message):
    __PB2_CLASS__ = job_service_pb2.ListJobsResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.ai.v1.ListJobsResponse",job_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[Job]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[Job]":
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Job,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[Job]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    

class JobServiceClient(client.ClientWithOperations[v1_1.Operation,v1_1.OperationServiceClient]):
    """
    Service to create/manage jobs.
    
    This class provides the client methods for the ``.nebius.ai.v1.JobService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.ai.v1.JobService",job_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.ai.v1.JobService"
    __operation_type__ = v1_1.Operation
    __operation_service_class__ = v1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def get(self,
        request: "GetJobRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["GetJobRequest","Job"]:
        """
        Returns the specified job.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.ai.v1.GetJobRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.ai.v1.Job`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=job_pb2.Job,
            result_wrapper=pb_classes.simple_wrapper(Job),
            **kwargs,
        )
    
    def get_by_name(self,
        request: "GetJobByNameRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["GetJobByNameRequest","Job"]:
        """
        Returns the specified job by name.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.ai.v1.GetJobByNameRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.ai.v1.Job`.
        """
        
        return super().request(
            method="GetByName",
            request=request,
            result_pb2_class=job_pb2.Job,
            result_wrapper=pb_classes.simple_wrapper(Job),
            **kwargs,
        )
    
    def list(self,
        request: "ListJobsRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["ListJobsRequest","ListJobsResponse"]:
        """
        Retrieves a list of jobs.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.ai.v1.ListJobsRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.ai.v1.ListJobsResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=job_service_pb2.ListJobsResponse,
            result_wrapper=pb_classes.simple_wrapper(ListJobsResponse),
            **kwargs,
        )
    
    def create(self,
        request: "CreateJobRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["CreateJobRequest","operation.Operation[v1_1.Operation]"]:
        """
        Creates a job.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.ai.v1.CreateJobRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation.Operation,
            **kwargs,
        )
    
    def delete(self,
        request: "DeleteJobRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["DeleteJobRequest","operation.Operation[v1_1.Operation]"]:
        """
        Deletes a job.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.ai.v1.DeleteJobRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation.Operation,
            **kwargs,
        )
    
    def cancel(self,
        request: "CancelJobRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["CancelJobRequest","operation.Operation[v1_1.Operation]"]:
        """
        Cancels a job.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.ai.v1.CancelJobRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Cancel",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation.Operation,
            **kwargs,
        )
    

__all__ = [
    #@ local import names here @#
    "Endpoint",
    "EndpointSpec",
    "EndpointStatus",
    "EndpointStateDetails",
    "EndpointInstanceStatus",
    "GetEndpointRequest",
    "GetEndpointByNameRequest",
    "ListEndpointsRequest",
    "CreateEndpointRequest",
    "DeleteEndpointRequest",
    "UpdateEndpointRequest",
    "StartEndpointRequest",
    "StopEndpointRequest",
    "ListEndpointsResponse",
    "EndpointServiceClient",
    "Job",
    "JobSpec",
    "JobStatus",
    "JobStateDetails",
    "JobInstanceStatus",
    "GetJobRequest",
    "GetJobByNameRequest",
    "ListJobsRequest",
    "CreateJobRequest",
    "DeleteJobRequest",
    "CancelJobRequest",
    "ListJobsResponse",
    "JobServiceClient",
]
